<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Shepherd</title>
  <style>
    :root {
      --hud-text: #f3f8ff;
      --hud-accent: #8fe4ff;
      --panel-bg: rgba(7, 11, 23, 0.78);
      --station-ok: #55ff95;
      --station-warn: #ffd166;
      --station-bad: #ff5d73;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle at 25% 20%, #293d78 0%, #151d3f 42%, #0a0d1f 100%);
      overflow: hidden;
      color: #fff;
    }

    #game-container {
      position: relative;
      width: 640px;
      height: 480px;
      border: 3px solid #2f4574;
      border-radius: 10px;
      box-shadow: 0 20px 65px rgba(0, 0, 0, 0.6);
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 640px;
      height: 480px;
      background: linear-gradient(180deg, #0d1330 0%, #0b122f 60%, #0a1028 100%);
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      inset: 12px 12px auto 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      color: var(--hud-text);
      text-shadow: 2px 2px 0 #000;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    #score-display {
      font-size: 24px;
      color: var(--hud-accent);
      min-width: 140px;
    }

    #station-hud {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
      min-width: 190px;
    }

    .station-row {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 180px;
      font-size: 13px;
      color: #dce6ff;
      justify-content: flex-end;
    }

    .station-label {
      width: 26px;
      text-align: right;
      opacity: 0.95;
    }

    .station-bar {
      width: 92px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid #38528f;
      background: rgba(10, 18, 42, 0.9);
      overflow: hidden;
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.6);
    }

    .station-fill {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #71ffa9, #36d97f);
      transition: width 0.16s linear;
    }

    .station-fill.warn {
      background: linear-gradient(90deg, #ffe08c, #ffb347);
    }

    .station-fill.bad {
      background: linear-gradient(90deg, #ff8093, #ff4d67);
    }

    .station-fill.dead {
      width: 0 !important;
    }

    .station-hp {
      width: 42px;
      text-align: left;
      color: #b7c6ea;
      font-size: 12px;
    }

    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      background: var(--panel-bg);
      pointer-events: auto;
    }

    h1 {
      margin: 0;
      font-size: 50px;
      line-height: 0.95;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #b0edff;
      text-shadow: 0 0 18px rgba(98, 213, 255, 0.4);
    }

    .subtitle {
      margin: 10px 0 18px;
      color: #d2def6;
      font-size: 17px;
      max-width: 480px;
      line-height: 1.45;
    }

    .controls {
      font-size: 14px;
      line-height: 1.7;
      color: #9fb3df;
      margin-bottom: 20px;
    }

    .key {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 6px;
      border: 1px solid #3f568f;
      background: #1a2850;
      color: #e5f7ff;
      font-size: 12px;
      font-weight: 700;
      margin: 0 2px;
      min-width: 22px;
    }

    .btn {
      border: none;
      border-radius: 8px;
      padding: 12px 28px;
      font-size: 20px;
      font-weight: 700;
      color: #122543;
      cursor: pointer;
      background: linear-gradient(180deg, #9df4ff 0%, #67dbff 100%);
      box-shadow: 0 6px 0 #3298c5;
      transition: transform 0.08s ease;
    }

    .btn:active {
      transform: translateY(6px);
      box-shadow: none;
    }

    #game-over-screen h1 {
      color: #ffbdaf;
      text-shadow: 0 0 18px rgba(255, 142, 129, 0.45);
    }

    #final-score,
    #final-time {
      margin: 6px 0;
      font-size: 22px;
      color: #f3f7ff;
      font-weight: 700;
    }

    #final-note {
      margin-top: 8px;
      color: #b5c7ea;
      font-size: 14px;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>

    <div id="ui-layer">
      <div class="hud">
        <div id="score-display">SCORE: 0</div>
        <div id="station-hud"></div>
      </div>

      <div id="start-screen" class="screen">
        <h1>Asteroid Shepherd</h1>
        <p class="subtitle">Bump drifting asteroids away from fragile edge stations. No weapons, only momentum.</p>
        <div class="controls">
          Rotate: <span class="key">A</span><span class="key">D</span> or <span class="key">←</span><span class="key">→</span><br>
          Thrust: <span class="key">W</span> or <span class="key">↑</span> | Brake: <span class="key">S</span> / <span class="key">↓</span> / <span class="key">Space</span><br>
          Touch: Hold left/right side to steer, hold anywhere to thrust
        </div>
        <button class="btn" id="start-btn">Start Patrol</button>
      </div>

      <div id="game-over-screen" class="screen hidden">
        <h1>Stations Lost</h1>
        <p id="final-score">Score: 0</p>
        <p id="final-time">Survived: 0.0s</p>
        <p id="final-note">Press Enter or tap Restart to try again.</p>
        <button class="btn" id="restart-btn">Restart</button>
      </div>
    </div>
  </div>

  <script>
    /**
     * ==========================================
     * 1. UTILITY CLASSES
     * ==========================================
     */

    class InputManager {
      constructor(canvas) {
        this.canvas = canvas;
        this.keys = {};
        this.down = {};
        this.pressed = {};
        this.pointer = {
          active: false,
          x: canvas.width * 0.5,
          y: canvas.height * 0.5,
          started: false
        };

        window.addEventListener("keydown", (e) => {
          if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Space", "Enter"].includes(e.code)) {
            e.preventDefault();
          }

          this.keys[e.code] = true;
          if (!this.down[e.code]) {
            this.down[e.code] = true;
            this.pressed[e.code] = true;
          }
        });

        window.addEventListener("keyup", (e) => {
          this.keys[e.code] = false;
          this.down[e.code] = false;
          this.pressed[e.code] = false;
        });

        canvas.addEventListener("mousedown", (e) => {
          const p = this.getCanvasPosition(e.clientX, e.clientY);
          this.pointer.active = true;
          this.pointer.started = true;
          this.pointer.x = p.x;
          this.pointer.y = p.y;
        });

        window.addEventListener("mousemove", (e) => {
          if (!this.pointer.active) return;
          const p = this.getCanvasPosition(e.clientX, e.clientY);
          this.pointer.x = p.x;
          this.pointer.y = p.y;
        });

        window.addEventListener("mouseup", () => {
          this.pointer.active = false;
        });

        canvas.addEventListener("touchstart", (e) => {
          if (e.touches.length === 0) return;
          e.preventDefault();
          const t = e.touches[0];
          const p = this.getCanvasPosition(t.clientX, t.clientY);
          this.pointer.active = true;
          this.pointer.started = true;
          this.pointer.x = p.x;
          this.pointer.y = p.y;
        }, { passive: false });

        canvas.addEventListener("touchmove", (e) => {
          if (e.touches.length === 0) return;
          e.preventDefault();
          const t = e.touches[0];
          const p = this.getCanvasPosition(t.clientX, t.clientY);
          this.pointer.x = p.x;
          this.pointer.y = p.y;
        }, { passive: false });

        canvas.addEventListener("touchend", (e) => {
          e.preventDefault();
          this.pointer.active = false;
        }, { passive: false });
      }

      getCanvasPosition(clientX, clientY) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: clientX - rect.left,
          y: clientY - rect.top
        };
      }

      isRotateLeft() {
        const keyboard = this.isDown("ArrowLeft") || this.isDown("KeyA");
        const pointer = this.pointer.active && this.pointer.x < this.canvas.width * 0.42;
        return keyboard || pointer;
      }

      isRotateRight() {
        const keyboard = this.isDown("ArrowRight") || this.isDown("KeyD");
        const pointer = this.pointer.active && this.pointer.x > this.canvas.width * 0.58;
        return keyboard || pointer;
      }

      isThrusting() {
        return this.isDown("ArrowUp") || this.isDown("KeyW") || this.pointer.active;
      }

      isBraking() {
        return this.isDown("ArrowDown") || this.isDown("KeyS") || this.isDown("Space");
      }

      isDown(code) {
        return !!this.keys[code];
      }

      isPressed(code) {
        return !!this.pressed[code];
      }

      isStartActionPressed() {
        return this.isPressed("Enter") || this.isPressed("Space") || this.pointer.started;
      }

      endFrame() {
        for (const code in this.pressed) {
          this.pressed[code] = false;
        }
        this.pointer.started = false;
      }
    }

    class Vector2 {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }

      length() {
        return Math.hypot(this.x, this.y);
      }

      normalize() {
        const len = this.length();
        if (len <= 0.000001) return this;
        this.x /= len;
        this.y /= len;
        return this;
      }

      static distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
    }

    /**
     * ==========================================
     * 2. BASE GAME OBJECT CLASS
     * ==========================================
     */

    class GameObject {
      constructor(x, y, radius = 0) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.markedForDeletion = false;
      }

      update(dt) {}
      render(ctx) {}
    }

    /**
     * ==========================================
     * 3. GAME ENTITIES
     * ==========================================
     */

    class Ship extends GameObject {
      constructor(x, y) {
        super(x, y, 14);
        this.vx = 0;
        this.vy = 0;
        this.angle = -Math.PI / 2;
        this.mass = 56;

        this.turnSpeed = 3.7;
        this.thrustForce = 240;
        this.brakeStrength = 2.3;
        this.drag = 0.988;
        this.maxSpeed = 270;
        this.thrusting = false;
      }

      update(dt, input, game) {
        if (input.isRotateLeft()) this.angle -= this.turnSpeed * dt;
        if (input.isRotateRight()) this.angle += this.turnSpeed * dt;

        this.thrusting = input.isThrusting();
        if (this.thrusting) {
          this.vx += Math.cos(this.angle) * this.thrustForce * dt;
          this.vy += Math.sin(this.angle) * this.thrustForce * dt;

          game.spawnThrusterParticle(
            this.x - Math.cos(this.angle) * (this.radius + 8),
            this.y - Math.sin(this.angle) * (this.radius + 8),
            this.angle
          );
        }

        if (input.isBraking()) {
          const brakeScale = Math.max(0.2, 1 - this.brakeStrength * dt);
          this.vx *= brakeScale;
          this.vy *= brakeScale;
        }

        const dragFactor = Math.pow(this.drag, dt * 60);
        this.vx *= dragFactor;
        this.vy *= dragFactor;

        const speed = Math.hypot(this.vx, this.vy);
        if (speed > this.maxSpeed) {
          const s = this.maxSpeed / speed;
          this.vx *= s;
          this.vy *= s;
        }

        this.x += this.vx * dt;
        this.y += this.vy * dt;
        game.wrapCircle(this);
      }

      render(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        ctx.shadowColor = "rgba(121, 219, 255, 0.65)";
        ctx.shadowBlur = 12;

        ctx.fillStyle = "#b8f0ff";
        ctx.beginPath();
        ctx.moveTo(17, 0);
        ctx.lineTo(-10, -11);
        ctx.lineTo(-7, 0);
        ctx.lineTo(-10, 11);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = "#2e6a9a";
        ctx.lineWidth = 2;
        ctx.stroke();

        if (this.thrusting) {
          ctx.fillStyle = "#ffb26e";
          ctx.beginPath();
          ctx.moveTo(-9, -5);
          ctx.lineTo(-20 - Math.random() * 8, 0);
          ctx.lineTo(-9, 5);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
      }
    }

    class Asteroid extends GameObject {
      constructor(x, y, radius, speed, angle) {
        super(x, y, radius);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.mass = Math.max(10, radius * radius * 0.065);
        this.rotation = Math.random() * Math.PI * 2;
        this.spin = (Math.random() - 0.5) * 1.6;
        this.hitCooldown = 0;

        this.profile = [];
        const points = 11;
        for (let i = 0; i < points; i++) {
          const t = (i / points) * Math.PI * 2;
          const jitter = 0.78 + Math.random() * 0.34;
          this.profile.push({
            x: Math.cos(t) * this.radius * jitter,
            y: Math.sin(t) * this.radius * jitter
          });
        }
      }

      update(dt, game) {
        this.hitCooldown = Math.max(0, this.hitCooldown - dt);

        const speedRamp = 1 + game.survivalTime * game.speedRampRate;
        const currentSpeed = Math.hypot(this.vx, this.vy);
        const targetMax = Math.min(230, (48 + this.radius * 1.5) * speedRamp);

        if (currentSpeed > targetMax) {
          const s = targetMax / currentSpeed;
          this.vx *= s;
          this.vy *= s;
        } else {
          const driftBoost = 1 + dt * 0.05;
          this.vx *= driftBoost;
          this.vy *= driftBoost;
        }

        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.rotation += this.spin * dt;

        game.wrapCircle(this);
      }

      render(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.fillStyle = "#8d8c9f";
        ctx.strokeStyle = "#3d405e";
        ctx.lineWidth = 2;

        ctx.beginPath();
        for (let i = 0; i < this.profile.length; i++) {
          const p = this.profile[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "rgba(210, 215, 238, 0.24)";
        ctx.beginPath();
        ctx.arc(-this.radius * 0.2, -this.radius * 0.15, this.radius * 0.23, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    class Station extends GameObject {
      constructor(x, y, radius, maxHp, id) {
        super(x, y, radius);
        this.id = id;
        this.maxHp = maxHp;
        this.hp = maxHp;
        this.destroyed = false;
      }

      takeHit() {
        if (this.destroyed) return false;
        this.hp = Math.max(0, this.hp - 1);
        if (this.hp <= 0) this.destroyed = true;
        return true;
      }

      render(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);

        const hpRatio = this.hp / this.maxHp;
        const glow = this.destroyed ? "rgba(255, 92, 116, 0.2)" : `rgba(95, 255, 184, ${0.18 + hpRatio * 0.35})`;
        ctx.shadowBlur = 18;
        ctx.shadowColor = glow;

        ctx.fillStyle = this.destroyed ? "#562f46" : "#87ffd1";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.destroyed ? "#a34f6c" : "#2f8f70";
        ctx.stroke();

        ctx.fillStyle = this.destroyed ? "#8c3f58" : "#0f3f35";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.45, 0, Math.PI * 2);
        ctx.fill();

        if (this.destroyed) {
          ctx.strokeStyle = "#f0a3b2";
          ctx.lineWidth = 2.2;
          ctx.beginPath();
          ctx.moveTo(-this.radius * 0.45, -this.radius * 0.45);
          ctx.lineTo(this.radius * 0.45, this.radius * 0.45);
          ctx.moveTo(this.radius * 0.45, -this.radius * 0.45);
          ctx.lineTo(-this.radius * 0.45, this.radius * 0.45);
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    class Particle extends GameObject {
      constructor(x, y, radius, color, vx, vy, life, decay) {
        super(x, y, radius);
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
        this.decay = decay;
      }

      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= this.decay * dt;
        this.vx *= 0.98;
        this.vy *= 0.98;
        if (this.life <= 0) this.markedForDeletion = true;
      }

      render(ctx) {
        const alpha = Math.max(0, this.life / this.maxLife);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    /**
     * ==========================================
     * 4. GAME MANAGER
     * ==========================================
     */

    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.input = new InputManager(canvas);

        this.width = canvas.width;
        this.height = canvas.height;

        this.states = {
          START: "START",
          PLAYING: "PLAYING",
          GAMEOVER: "GAMEOVER"
        };

        this.state = this.states.START;
        this.lastTime = performance.now();

        this.starfield = this.createStarfield();
        this.screenShake = 0;
        this.screenShakeMag = 0;

        this.speedRampRate = 0.012;
        this.spawnCap = 20;

        this.ui = {
          score: document.getElementById("score-display"),
          stationHud: document.getElementById("station-hud"),
          start: document.getElementById("start-screen"),
          over: document.getElementById("game-over-screen"),
          finalScore: document.getElementById("final-score"),
          finalTime: document.getElementById("final-time")
        };

        document.getElementById("start-btn").addEventListener("click", () => this.start());
        document.getElementById("restart-btn").addEventListener("click", () => this.start());

        this.resetRun();
        requestAnimationFrame((t) => this.loop(t));
      }

      createStarfield() {
        const stars = [];
        for (let i = 0; i < 90; i++) {
          stars.push({
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            size: Math.random() < 0.15 ? 2 : 1,
            speed: 5 + Math.random() * 22,
            alpha: 0.25 + Math.random() * 0.75
          });
        }
        return stars;
      }

      resetRun() {
        this.ship = new Ship(this.width * 0.5, this.height * 0.5);
        this.asteroids = [];
        this.particles = [];
        this.stationRows = [];

        this.survivalTime = 0;
        this.score = 0;
        this.spawnTimer = this.randomSpawnDelay();
        this.screenShake = 0;

        this.stations = this.createStations();
        this.buildStationHud();

        for (let i = 0; i < 3; i++) {
          this.spawnAsteroid();
        }

        this.updateUI();
      }

      createStations() {
        const maxHp = 6;
        return [
          new Station(58, 120, 24, maxHp, 1),
          new Station(this.width - 60, 240, 24, maxHp, 2),
          new Station(320, this.height - 52, 24, maxHp, 3)
        ];
      }

      buildStationHud() {
        this.ui.stationHud.innerHTML = "";
        this.stationRows.length = 0;

        this.stations.forEach((station) => {
          const row = document.createElement("div");
          row.className = "station-row";

          const label = document.createElement("span");
          label.className = "station-label";
          label.textContent = `S${station.id}`;

          const bar = document.createElement("span");
          bar.className = "station-bar";

          const fill = document.createElement("span");
          fill.className = "station-fill";
          bar.appendChild(fill);

          const hp = document.createElement("span");
          hp.className = "station-hp";

          row.appendChild(label);
          row.appendChild(bar);
          row.appendChild(hp);
          this.ui.stationHud.appendChild(row);

          this.stationRows.push({ station, fill, hp });
        });
      }

      randomSpawnDelay() {
        return 10 + Math.random() * 5;
      }

      start() {
        this.resetRun();
        this.state = this.states.PLAYING;
        this.ui.start.classList.add("hidden");
        this.ui.over.classList.add("hidden");
      }

      gameOver() {
        this.state = this.states.GAMEOVER;
        this.ui.finalScore.textContent = `Score: ${Math.floor(this.score)}`;
        this.ui.finalTime.textContent = `Survived: ${this.survivalTime.toFixed(1)}s`;
        this.ui.over.classList.remove("hidden");
      }

      getActiveStationCount() {
        let count = 0;
        for (const station of this.stations) {
          if (!station.destroyed) count++;
        }
        return count;
      }

      updateUI() {
        this.ui.score.textContent = `SCORE: ${Math.floor(this.score)}`;

        for (const row of this.stationRows) {
          const ratio = row.station.hp / row.station.maxHp;
          const pct = Math.max(0, ratio * 100);
          row.fill.style.width = `${pct}%`;
          row.fill.classList.remove("warn", "bad", "dead");

          if (row.station.destroyed) {
            row.fill.classList.add("dead");
          } else if (ratio <= 0.34) {
            row.fill.classList.add("bad");
          } else if (ratio <= 0.67) {
            row.fill.classList.add("warn");
          }

          row.hp.textContent = row.station.destroyed ? "X" : `${row.station.hp}/${row.station.maxHp}`;
        }
      }

      wrapCircle(obj) {
        if (obj.x < -obj.radius) obj.x = this.width + obj.radius;
        else if (obj.x > this.width + obj.radius) obj.x = -obj.radius;

        if (obj.y < -obj.radius) obj.y = this.height + obj.radius;
        else if (obj.y > this.height + obj.radius) obj.y = -obj.radius;
      }

      spawnThrusterParticle(x, y, shipAngle) {
        if (Math.random() > 0.65) return;

        const spread = (Math.random() - 0.5) * 0.75;
        const angle = shipAngle + Math.PI + spread;
        const speed = 70 + Math.random() * 65;

        this.particles.push(
          new Particle(
            x,
            y,
            2 + Math.random() * 2,
            Math.random() < 0.5 ? "#ffd08a" : "#ff8f68",
            Math.cos(angle) * speed,
            Math.sin(angle) * speed,
            0.35 + Math.random() * 0.18,
            1.5
          )
        );
      }

      createImpactBurst(x, y, color, count, speedMul = 1) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = (35 + Math.random() * 130) * speedMul;
          this.particles.push(
            new Particle(
              x,
              y,
              1.4 + Math.random() * 2.4,
              color,
              Math.cos(angle) * speed,
              Math.sin(angle) * speed,
              0.4 + Math.random() * 0.35,
              1.45
            )
          );
        }
      }

      spawnAsteroid() {
        if (this.asteroids.length >= this.spawnCap) return;

        const roll = Math.random();
        let radius = 18;
        if (roll < 0.22) radius = 30;
        else if (roll < 0.64) radius = 24;

        const difficulty = Math.min(2.2, 1 + this.survivalTime * this.speedRampRate);
        const speed = (36 + Math.random() * 28 + radius * 0.45) * difficulty;
        const angle = Math.random() * Math.PI * 2;

        let x = this.width * 0.5;
        let y = this.height * 0.5;
        let foundSpot = false;

        for (let tries = 0; tries < 90; tries++) {
          x = Math.random() * this.width;
          y = Math.random() * this.height;

          const distShip = Vector2.distance({ x, y }, this.ship);
          if (distShip < 150) continue;

          let valid = true;
          for (const station of this.stations) {
            const d = Vector2.distance({ x, y }, station);
            if (d < station.radius + radius + 64) {
              valid = false;
              break;
            }
          }

          if (valid) {
            foundSpot = true;
            break;
          }
        }

        if (!foundSpot) {
          x = Math.random() * this.width;
          y = Math.random() * this.height;
        }

        this.asteroids.push(new Asteroid(x, y, radius, speed, angle));
      }

      resolveElasticCollision(a, b, restitution = 0.95) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const minDist = a.radius + b.radius;
        const distSq = dx * dx + dy * dy;
        if (distSq >= minDist * minDist) return false;

        let dist = Math.sqrt(distSq);
        if (dist < 0.0001) {
          dist = 0.0001;
        }

        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;

        const aInvMass = 1 / a.mass;
        const bInvMass = 1 / b.mass;
        const invMassSum = aInvMass + bInvMass;

        a.x -= nx * overlap * (aInvMass / invMassSum);
        a.y -= ny * overlap * (aInvMass / invMassSum);
        b.x += nx * overlap * (bInvMass / invMassSum);
        b.y += ny * overlap * (bInvMass / invMassSum);

        const rvx = b.vx - a.vx;
        const rvy = b.vy - a.vy;
        const velAlongNormal = rvx * nx + rvy * ny;

        if (velAlongNormal > 0) return true;

        const impulse = (-(1 + restitution) * velAlongNormal) / invMassSum;
        const ix = impulse * nx;
        const iy = impulse * ny;

        a.vx -= ix * aInvMass;
        a.vy -= iy * aInvMass;
        b.vx += ix * bInvMass;
        b.vy += iy * bInvMass;

        return true;
      }

      handleShipAsteroidCollisions() {
        for (const asteroid of this.asteroids) {
          const collided = this.resolveElasticCollision(this.ship, asteroid, 1.02);
          if (!collided) continue;

          const hitX = (this.ship.x + asteroid.x) * 0.5;
          const hitY = (this.ship.y + asteroid.y) * 0.5;
          this.createImpactBurst(hitX, hitY, "#a7dfff", 8, 1.15);
        }
      }

      handleAsteroidAsteroidCollisions() {
        for (let i = 0; i < this.asteroids.length; i++) {
          for (let j = i + 1; j < this.asteroids.length; j++) {
            const a = this.asteroids[i];
            const b = this.asteroids[j];
            const collided = this.resolveElasticCollision(a, b, 0.96);
            if (!collided) continue;

            const hitX = (a.x + b.x) * 0.5;
            const hitY = (a.y + b.y) * 0.5;
            this.createImpactBurst(hitX, hitY, "#cfd8f8", 4, 0.75);
          }
        }
      }

      handleStationCollisions() {
        for (const asteroid of this.asteroids) {
          for (const station of this.stations) {
            if (station.destroyed) continue;

            const dx = asteroid.x - station.x;
            const dy = asteroid.y - station.y;
            const minDist = asteroid.radius + station.radius;
            const distSq = dx * dx + dy * dy;

            if (distSq >= minDist * minDist) continue;

            let dist = Math.sqrt(distSq);
            if (dist < 0.0001) dist = 0.0001;

            const nx = dx / dist;
            const ny = dy / dist;
            const overlap = minDist - dist;

            asteroid.x += nx * overlap;
            asteroid.y += ny * overlap;

            const velocityDot = asteroid.vx * nx + asteroid.vy * ny;
            if (velocityDot < 0) {
              asteroid.vx -= (1.8 * velocityDot) * nx;
              asteroid.vy -= (1.8 * velocityDot) * ny;
            }

            if (asteroid.hitCooldown <= 0) {
              const wasHit = station.takeHit();
              asteroid.hitCooldown = 0.45;

              if (wasHit) {
                this.screenShake = 0.22;
                this.screenShakeMag = 4.8;
                this.createImpactBurst(station.x + nx * station.radius, station.y + ny * station.radius, "#ff9cae", 12, 1.2);

                if (station.destroyed) {
                  this.createImpactBurst(station.x, station.y, "#ff5475", 24, 1.45);
                }
              }
            }
          }
        }
      }

      updateStars(dt) {
        const pace = this.state === this.states.PLAYING ? (1 + Math.min(1.8, this.survivalTime * 0.02)) : 1;
        for (const star of this.starfield) {
          star.y += star.speed * dt * pace;
          if (star.y > this.height + 1) {
            star.y = -2;
            star.x = Math.random() * this.width;
          }
        }
      }

      update(dt) {
        this.updateStars(dt);

        if (this.state === this.states.START) {
          if (this.input.isStartActionPressed()) this.start();
          return;
        }

        if (this.state === this.states.GAMEOVER) {
          if (this.input.isPressed("Enter") || this.input.isPressed("Space") || this.input.pointer.started) {
            this.start();
          }
          return;
        }

        this.survivalTime += dt;
        this.score += dt * this.getActiveStationCount();

        this.ship.update(dt, this.input, this);

        this.spawnTimer -= dt;
        if (this.spawnTimer <= 0) {
          this.spawnAsteroid();
          this.spawnTimer = this.randomSpawnDelay();
        }

        for (const asteroid of this.asteroids) {
          asteroid.update(dt, this);
        }

        this.handleShipAsteroidCollisions();
        this.handleAsteroidAsteroidCollisions();
        this.handleStationCollisions();

        for (const p of this.particles) {
          p.update(dt);
        }

        this.asteroids = this.asteroids.filter((a) => !a.markedForDeletion);
        this.particles = this.particles.filter((p) => !p.markedForDeletion);

        this.updateUI();

        if (this.getActiveStationCount() <= 0) {
          this.gameOver();
        }

        if (this.screenShake > 0) {
          this.screenShake = Math.max(0, this.screenShake - dt);
          if (this.screenShake <= 0) this.screenShakeMag = 0;
        }
      }

      renderBackground(ctx) {
        const grd = ctx.createLinearGradient(0, 0, 0, this.height);
        grd.addColorStop(0, "#0f1738");
        grd.addColorStop(0.6, "#0d1737");
        grd.addColorStop(1, "#0a112a");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, this.width, this.height);

        ctx.fillStyle = "rgba(28, 44, 92, 0.42)";
        for (let y = 0; y < this.height; y += 48) {
          ctx.fillRect(0, y, this.width, 1);
        }

        for (const star of this.starfield) {
          ctx.globalAlpha = star.alpha;
          ctx.fillStyle = "#dce6ff";
          ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        ctx.globalAlpha = 1;
      }

      renderWorld(ctx) {
        this.renderBackground(ctx);

        for (const station of this.stations) {
          station.render(ctx);
        }

        for (const asteroid of this.asteroids) {
          asteroid.render(ctx);
        }

        for (const p of this.particles) {
          p.render(ctx);
        }

        this.ship.render(ctx);
      }

      render() {
        this.ctx.clearRect(0, 0, this.width, this.height);

        if (this.screenShake > 0) {
          const intensity = this.screenShakeMag * (this.screenShake / 0.22);
          const sx = (Math.random() - 0.5) * intensity;
          const sy = (Math.random() - 0.5) * intensity;

          this.ctx.save();
          this.ctx.translate(sx, sy);
          this.renderWorld(this.ctx);
          this.ctx.restore();
        } else {
          this.renderWorld(this.ctx);
        }
      }

      loop(timestamp) {
        const dt = Math.min(0.1, (timestamp - this.lastTime) / 1000);
        this.lastTime = timestamp;

        this.update(dt);
        this.render();
        this.input.endFrame();

        requestAnimationFrame((t) => this.loop(t));
      }
    }

    /**
     * ==========================================
     * 5. INITIALIZATION
     * ==========================================
     */

    window.addEventListener("load", () => {
      const canvas = document.getElementById("gameCanvas");
      new Game(canvas);
    });
  </script>
</body>
</html>
