<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Modular Sokoban</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
 
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #444;
        }
 
        canvas {
            display: block;
            background-color: #2a2a2a;
        }
 
        #ui-overlay {
            margin-top: 15px;
            text-align: center;
        }
 
        .controls {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }
 
        .key {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #666;
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>
<body>
 
    <div id="game-container">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
    </div>
 
    <div id="ui-overlay">
        <h2>SOKOBAN PUZZLE</h2>
        <div class="controls">
            Move: <span class="key">WASD</span> or <span class="key">ARROWS</span> | 
            Reset Level: <span class="key">R</span> | 
            Next Level (Debug): <span class="key">N</span>
        </div>
    </div>
 
    <script>
        /**
         * 1. UTILITY CLASSES
         */
        class Vector2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            equals(other) {
                return this.x === other.x && this.y === other.y;
            }
 
            add(other) {
                return new Vector2(this.x + other.x, this.y + other.y);
            }
        }
 
        class InputManager {
            constructor() {
                this.keys = {};
                this.downKeys = {}; // Keys pressed this frame
                
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.downKeys[e.code] = true;
                    
                    // Prevent scrolling with arrows/space
                    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) {
                        e.preventDefault();
                    }
                });
 
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    delete this.downKeys[e.code];
                });
            }
 
            isKeyDown(code) {
                return this.keys[code] === true;
            }
 
            // Returns true only on the frame the key was pressed
            isKeyPressed(code) {
                if (this.downKeys[code]) {
                    delete this.downKeys[code]; // Consume the press
                    return true;
                }
                return false;
            }
        }
 
        /**
         * 2. BASE GAME OBJECT CLASS
         */
        class GameObject {
            constructor(gridX, gridY, size) {
                this.gridPos = new Vector2(gridX, gridY);
                this.size = size;
                // Visual position for smooth rendering (lerping) could be added here
                // For this strict grid game, we render based on gridPos directly
            }
 
            update(dt) {
                // Base update logic
            }
 
            render(ctx, offsetX, offsetY) {
                // Base render logic
            }
 
            getPixelPos(offsetX, offsetY) {
                return {
                    x: offsetX + this.gridPos.x * this.size,
                    y: offsetY + this.gridPos.y * this.size
                };
            }
        }
 
        /**
         * 3. SPECIFIC ENTITY CLASSES
         */
 
        class Wall extends GameObject {
            constructor(x, y, size) {
                super(x, y, size);
            }
 
            render(ctx, offsetX, offsetY) {
                const pos = this.getPixelPos(offsetX, offsetY);
                ctx.fillStyle = "#555";
                ctx.fillRect(pos.x, pos.y, this.size, this.size);
                
                // Bevel effect
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.strokeRect(pos.x + 2, pos.y + 2, this.size - 4, this.size - 4);
            }
        }
 
        class Target extends GameObject {
            constructor(x, y, size) {
                super(x, y, size);
            }
 
            render(ctx, offsetX, offsetY) {
                const pos = this.getPixelPos(offsetX, offsetY);
                const cx = pos.x + this.size / 2;
                const cy = pos.y + this.size / 2;
 
                ctx.beginPath();
                ctx.arc(cx, cy, this.size / 4, 0, Math.PI * 2);
                ctx.fillStyle = "#aa3333"; // Red dot
                ctx.fill();
                ctx.strokeStyle = "#ff5555";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
 
        class Box extends GameObject {
            constructor(x, y, size) {
                super(x, y, size);
                this.isOnTarget = false;
            }
 
            update(dt) {
                // Animation logic could go here
            }
 
            render(ctx, offsetX, offsetY) {
                const pos = this.getPixelPos(offsetX, offsetY);
                const padding = 4;
                
                // Color changes if on target
                ctx.fillStyle = this.isOnTarget ? "#4caf50" : "#cd853f"; // Green if set, Brown if not
                
                ctx.fillRect(pos.x + padding, pos.y + padding, this.size - padding*2, this.size - padding*2);
                
                // Cross detail
                ctx.beginPath();
                ctx.strokeStyle = this.isOnTarget ? "#2e7d32" : "#8b4513";
                ctx.lineWidth = 3;
                ctx.moveTo(pos.x + padding, pos.y + padding);
                ctx.lineTo(pos.x + this.size - padding, pos.y + this.size - padding);
                ctx.moveTo(pos.x + this.size - padding, pos.y + padding);
                ctx.lineTo(pos.x + padding, pos.y + this.size - padding);
                ctx.stroke();
                
                // Border
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.strokeRect(pos.x + padding, pos.y + padding, this.size - padding*2, this.size - padding*2);
            }
        }
 
        class Player extends GameObject {
            constructor(x, y, size) {
                super(x, y, size);
                this.faceDirection = 1; // 1 right, -1 left
            }
 
            move(dx, dy) {
                this.gridPos.x += dx;
                this.gridPos.y += dy;
                if(dx !== 0) this.faceDirection = dx;
            }
 
            render(ctx, offsetX, offsetY) {
                const pos = this.getPixelPos(offsetX, offsetY);
                const cx = pos.x + this.size / 2;
                const cy = pos.y + this.size / 2;
                const radius = (this.size / 2) - 4;
 
                // Body
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fillStyle = "#2196f3"; // Blue
                ctx.fill();
                
                // Eyes (direction based)
                ctx.fillStyle = "white";
                const eyeOffsetX = this.faceDirection * 6;
                
                // Left Eye
                ctx.beginPath();
                ctx.arc(cx + eyeOffsetX - 4, cy - 5, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Right Eye
                ctx.beginPath();
                ctx.arc(cx + eyeOffsetX + 4, cy - 5, 4, 0, Math.PI * 2);
                ctx.fill();
 
                // Pupils
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(cx + eyeOffsetX - 4 + (this.faceDirection*2), cy - 5, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cx + eyeOffsetX + 4 + (this.faceDirection*2), cy - 5, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
 
        /**
         * 4. LEVEL & GAME MANAGEMENT
         */
 
        class LevelData {
            constructor() {
                // Map Key: #:Wall, .:Floor, @:Player, $:Box, !:Target, *:BoxOnTarget
                this.levels = [
                    [   // Level 1
                        "##########",
                        "##########",
                        "##  !   ##",
                        "## $  $ ##",
                        "##  @   ##",
                        "## !!!  ##",
                        "##  $   ##",
                        "##########",
                        "##########",
                        "##########"
                    ],
                    [   // Level 2
                        "##########",
                        "###   ####",
                        "###$  ####",
                        "###  $!###",
                        "### !! ###",
                        "### $! ###",
                        "#### @ ###",
                        "##########",
                        "##########",
                        "##########"
                    ],
                    [   // Level 3
                        "##########",
                        "##  ### ##",
                        "## $ !  ##",
                        "##  $   ##",
                        "###  ! ###",
                        "##  $@ ###",
                        "## !  $ ##",
                        "##   ## ##",
                        "##########",
                        "##########"
                    ]
                ];
            }
 
            getLevel(index) {
                if (index < 0 || index >= this.levels.length) return null;
                return this.levels[index];
            }
        }
 
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                this.input = new InputManager();
                this.levelData = new LevelData();
                
                this.tileSize = 40;
                this.gridWidth = 10;
                this.gridHeight = 10;
                
                // Center the grid
                this.offsetX = (this.width - (this.gridWidth * this.tileSize)) / 2;
                this.offsetY = (this.height - (this.gridHeight * this.tileSize)) / 2;
 
                this.currentLevelIdx = 0;
                this.gameState = "PLAYING"; // PLAYING, WON
                
                // Game Entities
                this.walls = [];
                this.targets = [];
                this.boxes = [];
                this.player = null;
                this.floorTiles = []; // For rendering background grid
 
                // Start loop
                this.lastTime = 0;
            }
 
            start() {
                this.loadLevel(this.currentLevelIdx);
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }
 
            loadLevel(index) {
                const map = this.levelData.getLevel(index);
                if (!map) {
                    // Reset to 0 if out of levels (or show end screen)
                    this.currentLevelIdx = 0;
                    this.loadLevel(0);
                    return;
                }
 
                this.gameState = "PLAYING";
                this.walls = [];
                this.targets = [];
                this.boxes = [];
                this.floorTiles = [];
                this.player = null;
 
                for (let y = 0; y < this.gridHeight; y++) {
                    let row = map[y] || "          "; // fallback empty
                    for (let x = 0; x < this.gridWidth; x++) {
                        let char = row[x] || " ";
                        
                        // Always add floor unless it's strictly outside (simplified: everything is floor bg)
                        this.floorTiles.push(new Vector2(x, y));
 
                        if (char === '#') {
                            this.walls.push(new Wall(x, y, this.tileSize));
                        } else if (char === '!') {
                            this.targets.push(new Target(x, y, this.tileSize));
                        } else if (char === '$') {
                            this.boxes.push(new Box(x, y, this.tileSize));
                        } else if (char === '@') {
                            this.player = new Player(x, y, this.tileSize);
                        } else if (char === '*') {
                            this.boxes.push(new Box(x, y, this.tileSize));
                            this.targets.push(new Target(x, y, this.tileSize));
                        }
                    }
                }
                
                this.updateBoxStates();
            }
 
            update(dt) {
                if (this.gameState === "WON") {
                    if (this.input.isKeyPressed("Space") || this.input.isKeyPressed("Enter")) {
                        this.currentLevelIdx++;
                        this.loadLevel(this.currentLevelIdx);
                    }
                    return;
                }
 
                // Reset
                if (this.input.isKeyPressed("KeyR")) {
                    this.loadLevel(this.currentLevelIdx);
                }
 
                // Debug Skip
                if (this.input.isKeyPressed("KeyN")) {
                    this.currentLevelIdx++;
                    this.loadLevel(this.currentLevelIdx);
                }
 
                // Movement Input
                let dx = 0;
                let dy = 0;
 
                if (this.input.isKeyPressed("ArrowUp") || this.input.isKeyPressed("KeyW")) dy = -1;
                else if (this.input.isKeyPressed("ArrowDown") || this.input.isKeyPressed("KeyS")) dy = 1;
                else if (this.input.isKeyPressed("ArrowLeft") || this.input.isKeyPressed("KeyA")) dx = -1;
                else if (this.input.isKeyPressed("ArrowRight") || this.input.isKeyPressed("KeyD")) dx = 1;
 
                if (dx !== 0 || dy !== 0) {
                    this.attemptMove(dx, dy);
                }
            }
 
            attemptMove(dx, dy) {
                const targetPos = this.player.gridPos.add(new Vector2(dx, dy));
 
                // 1. Check Wall Collision
                if (this.isWallAt(targetPos)) return;
 
                // 2. Check Box Collision
                const box = this.getBoxAt(targetPos);
                if (box) {
                    const boxTargetPos = box.gridPos.add(new Vector2(dx, dy));
                    
                    // Can box move?
                    if (this.isWallAt(boxTargetPos) || this.getBoxAt(boxTargetPos)) {
                        return; // Blocked
                    }
 
                    // Move Box
                    box.gridPos = boxTargetPos;
                }
 
                // 3. Move Player
                this.player.move(dx, dy);
 
                // 4. Update Game State
                this.updateBoxStates();
                this.checkWinCondition();
            }
 
            isWallAt(pos) {
                return this.walls.some(w => w.gridPos.equals(pos));
            }
 
            getBoxAt(pos) {
                return this.boxes.find(b => b.gridPos.equals(pos));
            }
 
            updateBoxStates() {
                this.boxes.forEach(box => {
                    box.isOnTarget = this.targets.some(t => t.gridPos.equals(box.gridPos));
                });
            }
 
            checkWinCondition() {
                const allOnTarget = this.boxes.every(b => b.isOnTarget);
                if (allOnTarget && this.boxes.length > 0) {
                    this.gameState = "WON";
                }
            }
 
            render() {
                // Clear background
                this.ctx.fillStyle = "#2a2a2a";
                this.ctx.fillRect(0, 0, this.width, this.height);
 
                // Draw Floor Grid
                this.ctx.fillStyle = "#333";
                this.floorTiles.forEach(pos => {
                    this.ctx.fillRect(
                        this.offsetX + pos.x * this.tileSize + 1,
                        this.offsetY + pos.y * this.tileSize + 1,
                        this.tileSize - 2,
                        this.tileSize - 2
                    );
                });
 
                // Render Entities
                // Layer 1: Targets
                this.targets.forEach(t => t.render(this.ctx, this.offsetX, this.offsetY));
                
                // Layer 2: Walls
                this.walls.forEach(w => w.render(this.ctx, this.offsetX, this.offsetY));
                
                // Layer 3: Boxes
                this.boxes.forEach(b => b.render(this.ctx, this.offsetX, this.offsetY));
                
                // Layer 4: Player
                if (this.player) this.player.render(this.ctx, this.offsetX, this.offsetY);
 
                // UI Text
                this.renderUI();
            }
 
            renderUI() {
                this.ctx.fillStyle = "white";
                this.ctx.font = "20px Arial";
                this.ctx.textAlign = "left";
                this.ctx.fillText(`Level: ${this.currentLevelIdx + 1}`, 20, 30);
 
                if (this.gameState === "WON") {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    
                    this.ctx.fillStyle = "#4caf50";
                    this.ctx.font = "bold 40px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("LEVEL COMPLETE!", this.width / 2, this.height / 2 - 20);
                    
                    this.ctx.fillStyle = "white";
                    this.ctx.font = "20px Arial";
                    this.ctx.fillText("Press SPACE to continue", this.width / 2, this.height / 2 + 30);
                }
            }
 
            gameLoop(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;
 
                this.update(dt);
                this.render();
 
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }
        }
 
        /**
         * 5. INITIALIZATION
         */
        window.onload = () => {
            const canvas = document.getElementById('gameCanvas');
            const game = new Game(canvas);
            game.start();
        };
 
    </script>
</body>
</html>