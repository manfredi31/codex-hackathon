<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neon Nibble Snake</title>
  <style>
    :root {
      --bg-sky: #a9f3ff;
      --bg-sun: #ffe37a;
      --bg-mint: #baffc9;
      --accent: #ff9f1c;
      --accent-dark: #f77f00;
      --snake: #35d0ba;
      --snake-dark: #17a398;
      --snake-outline: #0c5c61;
      --food: #ff5fa2;
      --food-outline: #a12a5f;
      --hud: #1f2a44;
      --panel: rgba(255, 255, 255, 0.85);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, var(--bg-sun), var(--bg-sky) 45%, #7dd9ff 75%);
      font-family: "Comic Sans MS", "Chalkboard SE", "Marker Felt", "Trebuchet MS", sans-serif;
      overflow: hidden;
      color: var(--hud);
    }

    #game-container {
      position: relative;
      box-shadow: 0 18px 40px rgba(15, 40, 60, 0.35);
      border: 6px solid #2d2a4a;
      border-radius: 18px;
      overflow: hidden;
      background: #ffffff;
    }

    canvas {
      display: block;
      background: linear-gradient(180deg, #b6f2ff 0%, #7fd6ff 55%, #76e3b7 100%);
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      font-weight: 700;
      font-size: 20px;
      text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.2);
    }

    .hud span {
      display: inline-block;
      min-width: 120px;
    }

    #start-screen,
    #game-over-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.85);
      text-align: center;
      pointer-events: auto;
      padding: 24px;
    }

    h1 {
      margin: 0;
      font-size: 46px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: #2d2a4a;
      text-shadow: 2px 3px 0 #ffffff, 4px 5px 0 rgba(0, 0, 0, 0.1);
    }

    p {
      margin: 0;
      font-size: 18px;
      color: #3a4a66;
    }

    .hint {
      font-size: 16px;
      color: #59749b;
    }

    button {
      margin-top: 8px;
      padding: 12px 28px;
      font-size: 20px;
      font-weight: 700;
      border: 3px solid #2d2a4a;
      border-radius: 999px;
      background: linear-gradient(180deg, var(--accent), var(--accent-dark));
      color: #1f222a;
      cursor: pointer;
      box-shadow: 0 6px 0 rgba(45, 42, 74, 0.4);
    }

    button:active {
      transform: translateY(2px);
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>

    <div id="ui-layer">
      <div class="hud">
        <span id="score-display">SCORE: 0</span>
        <span id="status-display">LENGTH: 3</span>
        <span id="speed-display">SPEED: 1.0x</span>
      </div>

      <div id="start-screen">
        <h1>Neon Nibble Snake</h1>
        <p>Munch the candy fruit. Avoid walls and your own tail!</p>
        <p class="hint">Move with Arrow Keys or WASD. Tap/click to steer.</p>
        <p class="hint">Press Space/Enter to start.</p>
        <button id="start-btn">PLAY</button>
      </div>

      <div id="game-over-screen" class="hidden">
        <h1>Game Over</h1>
        <p id="final-score">Score: 0</p>
        <p class="hint">Press Space/Enter to try again.</p>
        <button id="restart-btn">RESTART</button>
      </div>
    </div>
  </div>

  <script>
    /**
     * 1. UTILITY CLASSES
     */
    class InputManager {
      constructor() {
        this.keys = {};
        this.pressed = {};
        this.down = {};

        window.addEventListener("keydown", (e) => {
          this.keys[e.code] = true;
          if (!this.down[e.code]) {
            this.pressed[e.code] = true;
            this.down[e.code] = true;
          }
        });

        window.addEventListener("keyup", (e) => {
          this.keys[e.code] = false;
          this.down[e.code] = false;
          this.pressed[e.code] = false;
        });
      }

      isDown(code) {
        return !!this.keys[code];
      }

      isPressed(code) {
        return !!this.pressed[code];
      }

      endFrame() {
        for (const code in this.pressed) {
          this.pressed[code] = false;
        }
      }
    }

    const randInt = (max) => Math.floor(Math.random() * max);
    const cssVars = getComputedStyle(document.documentElement);
    const COLORS = {
      snake: cssVars.getPropertyValue("--snake").trim() || "#35d0ba",
      snakeDark: cssVars.getPropertyValue("--snake-dark").trim() || "#17a398",
      snakeOutline: cssVars.getPropertyValue("--snake-outline").trim() || "#0c5c61",
      food: cssVars.getPropertyValue("--food").trim() || "#ff5fa2",
      foodOutline: cssVars.getPropertyValue("--food-outline").trim() || "#a12a5f"
    };

    const drawRoundedRect = (ctx, x, y, w, h, r) => {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    };

    /**
     * 2. BASE GAME OBJECT
     */
    class GameObject {
      constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.markedForDeletion = false;
      }

      update(dt) {}
      render(ctx) {}
    }

    /**
     * 3. GAME ENTITIES
     */
    class Food extends GameObject {
      constructor(cellX, cellY, size) {
        super(cellX * size, cellY * size, size, size);
        this.cellX = cellX;
        this.cellY = cellY;
        this.size = size;
        this.pulse = 0;
      }

      setCell(cellX, cellY) {
        this.cellX = cellX;
        this.cellY = cellY;
        this.x = cellX * this.size;
        this.y = cellY * this.size;
      }

      update(dt) {
        this.pulse += dt * 4;
      }

      render(ctx) {
        const centerX = this.x + this.size / 2;
        const centerY = this.y + this.size / 2;
        const pulse = 0.35 + Math.sin(this.pulse) * 0.12;
        ctx.save();
        ctx.shadowColor = "rgba(255, 95, 162, 0.6)";
        ctx.shadowBlur = 10;
        ctx.fillStyle = COLORS.food;
        ctx.strokeStyle = COLORS.foodOutline;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, this.size * 0.33 + pulse * 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.beginPath();
        ctx.arc(centerX - 4, centerY - 6, this.size * 0.12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#3bd48c";
        ctx.beginPath();
        ctx.ellipse(centerX + 4, centerY - 10, 6, 3, -0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class Particle extends GameObject {
      constructor(x, y, color) {
        super(x, y, 4, 4);
        this.vx = (Math.random() - 0.5) * 160;
        this.vy = (Math.random() - 0.5) * 160;
        this.life = 1.0;
        this.color = color;
      }

      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt * 2.5;
        if (this.life <= 0) this.markedForDeletion = true;
      }

      render(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    class Snake {
      constructor(startX, startY) {
        this.body = [
          { x: startX, y: startY },
          { x: startX - 1, y: startY },
          { x: startX - 2, y: startY }
        ];
        this.direction = { x: 1, y: 0 };
        this.nextDirection = { x: 1, y: 0 };
        this.pendingGrowth = 0;
      }

      setDirection(dir) {
        if (dir.x === -this.direction.x && dir.y === -this.direction.y) return;
        this.nextDirection = dir;
      }

      getNextHead() {
        return {
          x: this.body[0].x + this.nextDirection.x,
          y: this.body[0].y + this.nextDirection.y
        };
      }

      advance() {
        this.direction = { ...this.nextDirection };
        const next = this.getNextHead();
        this.body.unshift(next);
        if (this.pendingGrowth > 0) {
          this.pendingGrowth -= 1;
        } else {
          this.body.pop();
        }
      }

      grow(amount) {
        this.pendingGrowth += amount;
      }

      occupies(cellX, cellY, ignoreTail = false) {
        const length = ignoreTail ? this.body.length - 1 : this.body.length;
        for (let i = 0; i < length; i += 1) {
          if (this.body[i].x === cellX && this.body[i].y === cellY) {
            return true;
          }
        }
        return false;
      }
    }

    /**
     * 4. GAME MANAGER
     */
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.input = new InputManager();

        this.ui = {
          start: document.getElementById("start-screen"),
          over: document.getElementById("game-over-screen"),
          score: document.getElementById("score-display"),
          status: document.getElementById("status-display"),
          speed: document.getElementById("speed-display"),
          finalScore: document.getElementById("final-score")
        };

        this.gridSize = 20;
        this.gridWidth = canvas.width / this.gridSize;
        this.gridHeight = canvas.height / this.gridSize;

        this.state = "START";
        this.lastTime = 0;
        this.isRunning = false;
        this.stepTimer = 0;
        this.baseStep = 0.14;
        this.stepInterval = this.baseStep;
        this.shakeTime = 0;
        this.shakeDuration = 0.3;
        this.shakeStrength = 8;

        this.particles = [];
        this.reset();
        this.bindEvents();
        this.render();

        this.lastTime = performance.now();
        requestAnimationFrame((t) => this.loop(t));
      }

      bindEvents() {
        document.getElementById("start-btn").addEventListener("click", () => this.start());
        document.getElementById("restart-btn").addEventListener("click", () => this.start());

        window.addEventListener("keydown", (e) => {
          if (!this.isRunning && (e.code === "Space" || e.code === "Enter")) {
            this.start();
          }
        });

        const handlePointer = (clientX, clientY) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          const dx = x - rect.width / 2;
          const dy = y - rect.height / 2;
          if (Math.abs(dx) > Math.abs(dy)) {
            this.snake.setDirection({ x: dx > 0 ? 1 : -1, y: 0 });
          } else {
            this.snake.setDirection({ x: 0, y: dy > 0 ? 1 : -1 });
          }
        };

        this.canvas.addEventListener("click", (e) => {
          if (!this.isRunning) {
            this.start();
            return;
          }
          handlePointer(e.clientX, e.clientY);
        });

        this.canvas.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            if (!this.isRunning) {
              this.start();
              return;
            }
            const touch = e.touches[0];
            if (touch) handlePointer(touch.clientX, touch.clientY);
          },
          { passive: false }
        );
      }

      reset() {
        const startX = Math.floor(this.gridWidth / 2);
        const startY = Math.floor(this.gridHeight / 2);
        this.snake = new Snake(startX, startY);
        this.food = new Food(4, 4, this.gridSize);
        this.spawnFood();
        this.score = 0;
        this.stepTimer = 0;
        this.stepInterval = this.baseStep;
        this.particles = [];
        this.updateUI();
      }

      start() {
        if (this.isRunning) return;
        this.reset();
        this.state = "PLAYING";
        this.isRunning = true;
        this.ui.start.classList.add("hidden");
        this.ui.over.classList.add("hidden");
      }

      updateUI() {
        this.ui.score.textContent = `SCORE: ${this.score}`;
        this.ui.status.textContent = `LENGTH: ${this.snake.body.length}`;
        const speed = (this.baseStep / this.stepInterval).toFixed(1);
        this.ui.speed.textContent = `SPEED: ${speed}x`;
      }

      spawnFood() {
        let x = randInt(this.gridWidth);
        let y = randInt(this.gridHeight);
        let attempts = 0;
        while (this.snake.occupies(x, y) && attempts < 200) {
          x = randInt(this.gridWidth);
          y = randInt(this.gridHeight);
          attempts += 1;
        }
        this.food.setCell(x, y);
      }

      handleInput() {
        const directions = [
          { code: "ArrowUp", alt: "KeyW", dir: { x: 0, y: -1 } },
          { code: "ArrowDown", alt: "KeyS", dir: { x: 0, y: 1 } },
          { code: "ArrowLeft", alt: "KeyA", dir: { x: -1, y: 0 } },
          { code: "ArrowRight", alt: "KeyD", dir: { x: 1, y: 0 } }
        ];
        for (const entry of directions) {
          if (this.input.isPressed(entry.code) || this.input.isPressed(entry.alt)) {
            this.snake.setDirection(entry.dir);
          }
        }
      }

      step() {
        const nextHead = this.snake.getNextHead();
        const willGrow =
          nextHead.x === this.food.cellX && nextHead.y === this.food.cellY;

        if (
          nextHead.x < 0 ||
          nextHead.x >= this.gridWidth ||
          nextHead.y < 0 ||
          nextHead.y >= this.gridHeight
        ) {
          this.gameOver();
          return;
        }

        const ignoreTail = !willGrow && this.snake.pendingGrowth === 0;
        if (this.snake.occupies(nextHead.x, nextHead.y, ignoreTail)) {
          this.gameOver();
          return;
        }

        if (willGrow) {
          this.score += 1;
          this.snake.grow(2);
          this.spawnFood();
          this.createBurst(
            nextHead.x * this.gridSize + this.gridSize / 2,
            nextHead.y * this.gridSize + this.gridSize / 2,
            "#ffd166"
          );
          this.stepInterval = Math.max(0.07, this.baseStep - this.score * 0.002);
        }

        this.snake.advance();
      }

      createBurst(x, y, color) {
        for (let i = 0; i < 12; i += 1) {
          this.particles.push(new Particle(x, y, color));
        }
      }

      update(dt) {
        if (!this.isRunning) return;

        this.shakeTime = Math.max(0, this.shakeTime - dt);
        this.handleInput();

        this.stepTimer += dt;
        while (this.stepTimer >= this.stepInterval) {
          this.stepTimer -= this.stepInterval;
          if (!this.isRunning) break;
          this.step();
        }

        this.food.update(dt);
        this.particles.forEach((p) => p.update(dt));
        this.particles = this.particles.filter((p) => !p.markedForDeletion);

        this.updateUI();
        this.input.endFrame();
      }

      gameOver() {
        this.isRunning = false;
        this.state = "GAMEOVER";
        this.shakeTime = this.shakeDuration;
        this.ui.finalScore.textContent = `Score: ${this.score}`;
        this.ui.over.classList.remove("hidden");
      }

      renderBoard(ctx) {
        const size = this.gridSize;
        for (let y = 0; y < this.gridHeight; y += 1) {
          for (let x = 0; x < this.gridWidth; x += 1) {
            const isEven = (x + y) % 2 === 0;
            ctx.fillStyle = isEven ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.06)";
            ctx.fillRect(x * size, y * size, size, size);
          }
        }
      }

      renderSnake(ctx) {
        const size = this.gridSize;
        this.snake.body.forEach((segment, index) => {
          const x = segment.x * size;
          const y = segment.y * size;
          const isHead = index === 0;
          const inset = isHead ? 1 : 3;
          const w = size - inset * 2;
          const h = size - inset * 2;
          ctx.fillStyle = isHead ? COLORS.snake : COLORS.snakeDark;
          ctx.strokeStyle = COLORS.snakeOutline;
          ctx.lineWidth = 3;
          drawRoundedRect(ctx, x + inset, y + inset, w, h, 8);
          ctx.fill();
          ctx.stroke();

          if (isHead) {
            const eyeOffsetX = this.snake.direction.x === -1 ? 5 : 11;
            const eyeOffsetY = this.snake.direction.y === -1 ? 5 : 11;
            ctx.fillStyle = "#1f2a44";
            ctx.beginPath();
            ctx.arc(x + eyeOffsetX, y + 8, 3, 0, Math.PI * 2);
            ctx.arc(x + 8, y + eyeOffsetY, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x + eyeOffsetX - 1, y + 7, 1.2, 0, Math.PI * 2);
            ctx.arc(x + 7, y + eyeOffsetY - 1, 1.2, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = "#1f2a44";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 10, y + 14, 4, 0, Math.PI);
            ctx.stroke();
          }
        });
      }

      render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        let offsetX = 0;
        let offsetY = 0;
        if (this.shakeTime > 0) {
          const strength = (this.shakeTime / this.shakeDuration) * this.shakeStrength;
          offsetX = (Math.random() - 0.5) * strength;
          offsetY = (Math.random() - 0.5) * strength;
        }

        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.fillStyle = "rgba(255, 255, 255, 0.12)";
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.renderBoard(ctx);
        this.food.render(ctx);
        this.renderSnake(ctx);
        this.particles.forEach((p) => p.render(ctx));
        ctx.restore();
      }

      loop(timestamp) {
        const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
        this.lastTime = timestamp;
        if (this.isRunning) {
          this.update(dt);
        } else {
          this.input.endFrame();
        }
        this.render();
        requestAnimationFrame((t) => this.loop(t));
      }
    }

    /**
     * 5. INITIALIZATION
     */
    window.onload = () => {
      const canvas = document.getElementById("gameCanvas");
      new Game(canvas);
    };
  </script>
</body>
</html>
