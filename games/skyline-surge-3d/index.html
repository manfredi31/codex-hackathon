<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Skyline Surge: Cartoon Dash</title>
  <style>
    :root {
      --sky-top: #7fc9ff;
      --sky-mid: #9fe0ff;
      --sky-bottom: #ffe5b5;
      --ink: #1f2a39;
      --road: #48556b;
      --road-edge: #2e3848;
      --accent: #ffb347;
      --accent-2: #ff6b6b;
      --mint: #6bd6c7;
      --hud: rgba(255, 255, 255, 0.18);
      --hud-border: rgba(22, 30, 45, 0.55);
      --panel: rgba(17, 24, 36, 0.78);
      --text: #f7fbff;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at 15% 20%, rgba(255, 255, 255, 0.4), transparent 40%),
        radial-gradient(circle at 85% 15%, rgba(255, 255, 255, 0.35), transparent 35%),
        linear-gradient(180deg, #76c3ff 0%, #9edfff 48%, #f7d7a0 100%);
      font-family: "Comic Sans MS", "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--text);
      overflow: hidden;
    }

    #game-container {
      position: relative;
      width: 640px;
      height: 480px;
      border-radius: 18px;
      border: 4px solid #1b2636;
      box-shadow:
        0 20px 50px rgba(0, 0, 0, 0.35),
        inset 0 0 0 3px rgba(255, 255, 255, 0.12);
      background: #6cc2ff;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--sky-top) 0%, var(--sky-mid) 55%, var(--sky-bottom) 100%);
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .hud-box {
      background: var(--hud);
      border: 2px solid var(--hud-border);
      border-radius: 12px;
      padding: 6px 10px;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-shadow: 1px 2px 0 rgba(0, 0, 0, 0.3);
      text-align: center;
      backdrop-filter: blur(4px);
    }

    #shield-wrap {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 12px;
      display: grid;
      gap: 6px;
    }

    .shield-label {
      font-size: 14px;
      font-weight: 700;
      text-shadow: 1px 2px 0 rgba(0, 0, 0, 0.35);
      letter-spacing: 0.03em;
    }

    .shield-track {
      height: 14px;
      border-radius: 999px;
      border: 2px solid var(--hud-border);
      background: rgba(13, 20, 30, 0.6);
      overflow: hidden;
    }

    .shield-fill {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #7fe28c, #52c87a);
      transition: width 120ms linear;
      box-shadow: 0 0 10px rgba(96, 230, 144, 0.4);
    }

    .shield-fill.low {
      background: linear-gradient(90deg, #ff8b6b, #ff5a5a);
      box-shadow: 0 0 10px rgba(255, 90, 90, 0.4);
    }

    #start-screen,
    #game-over-screen {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--panel);
      text-align: center;
      pointer-events: auto;
    }

    .panel {
      width: min(100%, 560px);
      display: grid;
      gap: 12px;
      padding: 18px;
    }

    h1 {
      margin: 0;
      font-size: 40px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      text-shadow: 2px 3px 0 rgba(0, 0, 0, 0.4);
    }

    p {
      margin: 0;
      line-height: 1.4;
      color: #dfeaff;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.14);
      font-size: 13px;
      font-weight: 700;
    }

    button {
      margin-top: 10px;
      padding: 12px 26px;
      border-radius: 999px;
      border: 2px solid #1b2636;
      background: linear-gradient(135deg, #ffe57a 0%, #ffb347 100%);
      color: #1f2a39;
      font-weight: 800;
      letter-spacing: 0.06em;
      cursor: pointer;
      text-transform: uppercase;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
    }

    button:active {
      transform: translateY(1px);
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>

    <div id="ui-layer">
      <div class="hud">
        <div class="hud-box" id="score-display">SCORE: 0</div>
        <div class="hud-box" id="speed-display">SPEED: 0</div>
        <div class="hud-box" id="combo-display">COMBO x1</div>
        <div class="hud-box" id="star-display">STARS: 0</div>
      </div>

      <div id="shield-wrap">
        <div class="shield-label" id="shield-label">SHIELD 100%</div>
        <div class="shield-track">
          <div class="shield-fill" id="shield-fill"></div>
        </div>
      </div>

      <div id="start-screen">
        <div class="panel">
          <h1>Skyline Surge</h1>
          <p>Dash through a candy-colored skyline. Swap lanes, jump, and roll to dodge goofy obstacles and grab sparkle stars.</p>
          <div class="controls">
            <span class="pill">Left/Right or A/D: Lanes</span>
            <span class="pill">Up or Space: Jump</span>
            <span class="pill">Down or S: Roll</span>
            <span class="pill">Tap Left/Right: Lanes</span>
            <span class="pill">Tap Top: Jump</span>
            <span class="pill">Tap Bottom: Roll</span>
          </div>
          <button id="start-btn" type="button">Start Dash</button>
        </div>
      </div>

      <div id="game-over-screen" class="hidden">
        <div class="panel">
          <h1>Crash Landing</h1>
          <p id="final-score">Score: 0</p>
          <button id="restart-btn" type="button">Dash Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**
     * 1. UTILITY CLASSES
     */
    class InputManager {
      constructor(canvas) {
        this.canvas = canvas;
        this.down = {};
        this.pressed = {};
        this.pointerDown = false;
        this.pointerPressed = false;
        this.pointerX = 0;
        this.pointerY = 0;

        window.addEventListener("keydown", (event) => {
          const code = event.code;
          if (!this.down[code]) this.pressed[code] = true;
          this.down[code] = true;
        });

        window.addEventListener("keyup", (event) => {
          const code = event.code;
          this.down[code] = false;
          this.pressed[code] = false;
        });

        canvas.addEventListener(
          "pointerdown",
          (event) => {
            event.preventDefault();
            this.pointerDown = true;
            this.pointerPressed = true;
            this.updatePointer(event);
            canvas.setPointerCapture(event.pointerId);
          },
          { passive: false }
        );

        canvas.addEventListener("pointermove", (event) => {
          if (!this.pointerDown) return;
          this.updatePointer(event);
        });

        const release = (event) => {
          this.pointerDown = false;
          this.updatePointer(event);
        };
        canvas.addEventListener("pointerup", release);
        canvas.addEventListener("pointercancel", release);

        canvas.addEventListener("contextmenu", (event) => event.preventDefault());
      }

      updatePointer(event) {
        const rect = this.canvas.getBoundingClientRect();
        this.pointerX = Math.min(Math.max((event.clientX - rect.left) / rect.width, 0), 1);
        this.pointerY = Math.min(Math.max((event.clientY - rect.top) / rect.height, 0), 1);
      }

      isDown(code) {
        return !!this.down[code];
      }

      isPressed(code) {
        return !!this.pressed[code];
      }

      endFrame() {
        for (const key in this.pressed) this.pressed[key] = false;
        this.pointerPressed = false;
      }
    }

    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const lerp = (a, b, t) => a + (b - a) * t;
    const randRange = (min, max) => min + Math.random() * (max - min);

    const VIEW = {
      width: 640,
      height: 480,
      centerX: 320,
      horizon: 150,
      fov: 260,
      scale: 60,
      cameraY: 4.0
    };

    function projectPoint(x, y, z) {
      const depth = Math.max(1, z);
      const scale = VIEW.fov / (VIEW.fov + depth);
      return {
        x: VIEW.centerX + x * VIEW.scale * scale,
        y: VIEW.horizon + (VIEW.cameraY - y) * VIEW.scale * scale,
        scale
      };
    }

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w * 0.5, h * 0.5);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function drawStar(ctx, x, y, radius, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = color;
      ctx.strokeStyle = "#1f2a39";
      ctx.lineWidth = Math.max(2, radius * 0.25);
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
        const outerX = Math.cos(angle) * radius;
        const outerY = Math.sin(angle) * radius;
        const innerAngle = angle + Math.PI / 5;
        const innerX = Math.cos(innerAngle) * radius * 0.45;
        const innerY = Math.sin(innerAngle) * radius * 0.45;
        if (i === 0) ctx.moveTo(outerX, outerY);
        ctx.lineTo(outerX, outerY);
        ctx.lineTo(innerX, innerY);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    /**
     * 2. BASE GAME OBJECT
     */
    class GameObject {
      constructor() {
        this.markedForDeletion = false;
      }

      update(_dt, _game) {}
      render(_ctx, _game) {}
    }

    /**
     * 3. GAME ENTITIES
     */
    class Player extends GameObject {
      constructor(lanes) {
        super();
        this.lanes = lanes;
        this.lane = 1;
        this.x = lanes[this.lane];
        this.y = 0;
        this.vy = 0;
        this.rollTime = 0;
        this.invuln = 0;
        this.trail = [];
      }

      reset() {
        this.lane = 1;
        this.x = this.lanes[this.lane];
        this.y = 0;
        this.vy = 0;
        this.rollTime = 0;
        this.invuln = 0;
        this.trail.length = 0;
      }

      switchLane(direction) {
        this.lane = clamp(this.lane + direction, 0, this.lanes.length - 1);
      }

      jump() {
        if (this.y <= 0.01 && this.rollTime <= 0) {
          this.vy = 9.2;
        }
      }

      roll() {
        if (this.y <= 0.01) {
          this.rollTime = 0.55;
        }
      }

      update(dt) {
        const targetX = this.lanes[this.lane];
        this.x = lerp(this.x, targetX, Math.min(1, dt * 9));

        this.vy -= 18 * dt;
        this.y += this.vy * dt;
        if (this.y < 0) {
          this.y = 0;
          this.vy = 0;
        }

        if (this.rollTime > 0) {
          this.rollTime = Math.max(0, this.rollTime - dt);
        }

        this.invuln = Math.max(0, this.invuln - dt);

        this.trail.push({ x: this.x, y: this.y, life: 0.45 });
        for (const puff of this.trail) puff.life -= dt;
        this.trail = this.trail.filter((puff) => puff.life > 0);
      }

      render(ctx, game) {
        const playerZ = game.playerZ;
        const projection = projectPoint(this.x, this.y + 0.7, playerZ);
        const scale = projection.scale;
        const bodyW = 1.6 * VIEW.scale * scale;
        const bodyH = 0.9 * VIEW.scale * scale;
        const bodyX = projection.x - bodyW / 2;
        const bodyY = projection.y - bodyH;
        const blink = this.invuln > 0 && Math.floor(this.invuln * 18) % 2 === 0;

        for (const puff of this.trail) {
          const puffProj = projectPoint(puff.x, puff.y + 0.3, playerZ + 6);
          ctx.globalAlpha = Math.max(0, puff.life * 0.8);
          ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
          ctx.beginPath();
          ctx.ellipse(puffProj.x, puffProj.y + 14, 14 * puffProj.scale, 7 * puffProj.scale, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        const shadow = projectPoint(this.x, 0, playerZ + 2);
        ctx.fillStyle = "rgba(0, 0, 0, 0.22)";
        ctx.beginPath();
        ctx.ellipse(shadow.x, shadow.y + 22, 32 * shadow.scale, 10 * shadow.scale, 0, 0, Math.PI * 2);
        ctx.fill();

        if (blink) return;

        ctx.save();
        ctx.translate(projection.x, projection.y);
        ctx.rotate((this.x - game.lanes[1]) * 0.03);
        ctx.translate(-projection.x, -projection.y);

        drawRoundedRect(ctx, bodyX, bodyY, bodyW, bodyH, 16 * scale);
        ctx.fillStyle = "#6bd6c7";
        ctx.fill();
        ctx.lineWidth = Math.max(2, 5 * scale);
        ctx.strokeStyle = "#1f2a39";
        ctx.stroke();

        drawRoundedRect(ctx, projection.x - bodyW * 0.18, bodyY + bodyH * 0.18, bodyW * 0.36, bodyH * 0.35, 10 * scale);
        ctx.fillStyle = "#ffe5b5";
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath();
        ctx.moveTo(projection.x - bodyW * 0.45, bodyY + bodyH * 0.5);
        ctx.lineTo(projection.x - bodyW * 0.68, bodyY + bodyH * 0.68);
        ctx.lineTo(projection.x - bodyW * 0.45, bodyY + bodyH * 0.8);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(projection.x + bodyW * 0.45, bodyY + bodyH * 0.5);
        ctx.lineTo(projection.x + bodyW * 0.68, bodyY + bodyH * 0.68);
        ctx.lineTo(projection.x + bodyW * 0.45, bodyY + bodyH * 0.8);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        if (this.vy > 0.2 || this.rollTime <= 0) {
          ctx.fillStyle = "rgba(255, 255, 255, 0.65)";
          ctx.beginPath();
          ctx.ellipse(projection.x, bodyY + bodyH * 0.98, bodyW * 0.18, bodyH * 0.18, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        if (this.rollTime > 0) {
          ctx.fillStyle = "rgba(255, 193, 79, 0.8)";
          ctx.fillRect(projection.x - bodyW * 0.35, bodyY + bodyH * 0.7, bodyW * 0.7, bodyH * 0.12);
        }

        ctx.restore();
      }
    }

    class Obstacle extends GameObject {
      constructor(lane, z, kind) {
        super();
        this.lane = lane;
        this.z = z;
        this.kind = kind;
        this.w = kind === "block" ? 1.6 : 1.25;
        this.h = kind === "high" ? 2.2 : kind === "block" ? 1.6 : 0.9;
        this.color = kind === "high" ? "#8fd3ff" : kind === "block" ? "#ff8b6b" : "#ffd36b";
      }

      update(dt, game) {
        this.z -= game.speed * dt;
        if (this.z < -10) this.markedForDeletion = true;
      }

      render(ctx, game) {
        const laneX = game.lanes[this.lane];
        const projection = projectPoint(laneX, 0, this.z);
        const scale = projection.scale;
        const width = this.w * VIEW.scale * scale;
        const height = this.h * VIEW.scale * scale;
        const x = projection.x - width / 2;
        const y = projection.y - height;

        ctx.lineWidth = Math.max(2, 5 * scale);
        ctx.strokeStyle = "#1f2a39";
        ctx.fillStyle = this.color;

        if (this.kind === "high") {
          const pillarW = width * 0.28;
          drawRoundedRect(ctx, x, y, pillarW, height, 10 * scale);
          ctx.fill();
          ctx.stroke();
          drawRoundedRect(ctx, x + width - pillarW, y, pillarW, height, 10 * scale);
          ctx.fill();
          ctx.stroke();
          drawRoundedRect(ctx, x, y + height * 0.1, width, height * 0.2, 8 * scale);
          ctx.fillStyle = "#6bd6c7";
          ctx.fill();
          ctx.stroke();
        } else {
          drawRoundedRect(ctx, x, y, width, height, 12 * scale);
          ctx.fill();
          ctx.stroke();
        }
      }
    }

    class StarPickup extends GameObject {
      constructor(lane, z) {
        super();
        this.lane = lane;
        this.z = z;
        this.baseY = 1.2;
        this.age = randRange(0, Math.PI * 2);
      }

      update(dt, game) {
        this.z -= game.speed * dt;
        this.age += dt * 3;
        if (this.z < -10) this.markedForDeletion = true;
      }

      render(ctx, game) {
        const laneX = game.lanes[this.lane];
        const y = this.baseY + Math.sin(this.age) * 0.35;
        const projection = projectPoint(laneX, y, this.z);
        const radius = 0.55 * VIEW.scale * projection.scale;
        drawStar(ctx, projection.x, projection.y - radius * 0.3, radius, "#ffe57a");
      }
    }

    class Particle extends GameObject {
      constructor(x, y, color) {
        super();
        this.x = x;
        this.y = y;
        this.vx = randRange(-120, 120);
        this.vy = randRange(-120, 20);
        this.life = randRange(0.4, 0.8);
        this.color = color;
      }

      update(dt) {
        this.life -= dt;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += 220 * dt;
        if (this.life <= 0) this.markedForDeletion = true;
      }

      render(ctx) {
        ctx.globalAlpha = Math.max(0, this.life * 1.2);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    /**
     * 4. GAME MANAGER
     */
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.input = new InputManager(canvas);

        this.ui = {
          score: document.getElementById("score-display"),
          speed: document.getElementById("speed-display"),
          combo: document.getElementById("combo-display"),
          stars: document.getElementById("star-display"),
          shieldLabel: document.getElementById("shield-label"),
          shieldFill: document.getElementById("shield-fill"),
          finalScore: document.getElementById("final-score"),
          startScreen: document.getElementById("start-screen"),
          overScreen: document.getElementById("game-over-screen")
        };

        document.getElementById("start-btn").addEventListener("click", () => this.start());
        document.getElementById("restart-btn").addEventListener("click", () => this.start());

        this.state = "START";
        this.lastTime = performance.now();

        this.lanes = [-3.4, 0, 3.4];
        this.playerZ = 10;
        this.player = new Player(this.lanes);

        this.obstacles = [];
        this.stars = [];
        this.particles = [];
        this.laneMarkers = [];

        this.clouds = Array.from({ length: 6 }, () => ({
          x: randRange(40, 600),
          y: randRange(30, 140),
          scale: randRange(0.7, 1.2),
          speed: randRange(6, 16)
        }));

        this.buildings = [];
        let x = 0;
        while (x < VIEW.width + 40) {
          const width = randRange(24, 58);
          this.buildings.push({
            x,
            width,
            height: randRange(28, 110),
            color: `hsl(${randRange(200, 230)}, 35%, ${randRange(30, 50)}%)`
          });
          x += width + randRange(6, 18);
        }

        for (let i = 0; i < 20; i++) {
          this.laneMarkers.push(i * 12);
        }

        this.reset();
        requestAnimationFrame((t) => this.loop(t));
      }

      reset() {
        this.player.reset();
        this.obstacles.length = 0;
        this.stars.length = 0;
        this.particles.length = 0;

        this.score = 0;
        this.distance = 0;
        this.speed = 60;
        this.combo = 1;
        this.comboTimer = 0;
        this.shield = 100;
        this.starCount = 0;

        this.spawnTimer = 0.9;
        this.spawnInterval = 1.2;
        this.starTimer = 0.6;

        this.shakeTime = 0;
        this.shakeAmp = 0;
        this.flashTime = 0;

        this.updateUI();
      }

      start() {
        this.reset();
        this.state = "PLAYING";
        this.ui.startScreen.classList.add("hidden");
        this.ui.overScreen.classList.add("hidden");
      }

      gameOver() {
        this.state = "GAMEOVER";
        this.ui.finalScore.textContent = `Score: ${Math.floor(this.score)} | Stars: ${this.starCount}`;
        this.ui.overScreen.classList.remove("hidden");
      }

      spawnObstacle() {
        const lane = Math.floor(randRange(0, this.lanes.length));
        const roll = Math.random();
        const kind = roll < 0.35 ? "low" : roll < 0.7 ? "high" : "block";
        this.obstacles.push(new Obstacle(lane, 200, kind));
      }

      spawnStar() {
        const lane = Math.floor(randRange(0, this.lanes.length));
        this.stars.push(new StarPickup(lane, randRange(170, 210)));
      }

      spawnBurst(worldX, worldY, worldZ, color) {
        const projection = projectPoint(worldX, worldY, worldZ);
        for (let i = 0; i < 12; i++) {
          this.particles.push(new Particle(projection.x, projection.y, color));
        }
      }

      handleInput() {
        if (this.state !== "PLAYING") {
          if (this.input.isPressed("Enter") || this.input.isPressed("Space")) {
            this.start();
          }
          return;
        }

        if (this.input.isPressed("ArrowLeft") || this.input.isPressed("KeyA")) {
          this.player.switchLane(-1);
        }
        if (this.input.isPressed("ArrowRight") || this.input.isPressed("KeyD")) {
          this.player.switchLane(1);
        }
        if (this.input.isPressed("ArrowUp") || this.input.isPressed("KeyW") || this.input.isPressed("Space")) {
          this.player.jump();
        }
        if (this.input.isPressed("ArrowDown") || this.input.isPressed("KeyS")) {
          this.player.roll();
        }

        if (this.input.pointerPressed) {
          if (this.input.pointerY < 0.3) {
            this.player.jump();
          } else if (this.input.pointerY > 0.72) {
            this.player.roll();
          } else if (this.input.pointerX < 0.5) {
            this.player.switchLane(-1);
          } else {
            this.player.switchLane(1);
          }
        }
      }

      update(dt) {
        this.handleInput();
        if (this.state !== "PLAYING") return;

        this.speed = Math.min(120, this.speed + 4.2 * dt);
        this.distance += this.speed * dt;
        this.score += dt * this.speed * 0.6 + this.combo * 0.15;

        this.comboTimer = Math.max(0, this.comboTimer - dt);
        if (this.comboTimer <= 0) this.combo = 1;

        this.spawnTimer -= dt;
        if (this.spawnTimer <= 0) {
          this.spawnObstacle();
          this.spawnInterval = Math.max(0.62, this.spawnInterval - 0.006);
          this.spawnTimer = this.spawnInterval;
        }

        this.starTimer -= dt;
        if (this.starTimer <= 0) {
          this.spawnStar();
          this.starTimer = randRange(0.7, 1.4);
        }

        for (let i = 0; i < this.laneMarkers.length; i++) {
          this.laneMarkers[i] -= this.speed * dt;
          if (this.laneMarkers[i] < 0) this.laneMarkers[i] += 240;
        }

        for (const cloud of this.clouds) {
          cloud.x -= cloud.speed * dt;
          if (cloud.x < -120) cloud.x = VIEW.width + 120;
        }

        this.player.update(dt, this);
        this.obstacles.forEach((obstacle) => obstacle.update(dt, this));
        this.stars.forEach((star) => star.update(dt, this));
        this.particles.forEach((particle) => particle.update(dt));

        this.resolveCollisions();

        this.obstacles = this.obstacles.filter((obstacle) => !obstacle.markedForDeletion);
        this.stars = this.stars.filter((star) => !star.markedForDeletion);
        this.particles = this.particles.filter((particle) => !particle.markedForDeletion);

        this.shakeTime = Math.max(0, this.shakeTime - dt);
        this.flashTime = Math.max(0, this.flashTime - dt);

        this.updateUI();
      }

      resolveCollisions() {
        const playerLane = this.player.lane;
        const playerZ = this.playerZ;

        for (const obstacle of this.obstacles) {
          if (obstacle.markedForDeletion) continue;
          if (obstacle.lane !== playerLane) continue;
          const dz = Math.abs(obstacle.z - playerZ);
          if (dz > 4) continue;

          let safe = false;
          if (obstacle.kind === "low") {
            safe = this.player.y > 1.05;
          } else if (obstacle.kind === "high") {
            safe = this.player.rollTime > 0;
          }

          if (!safe) {
            obstacle.markedForDeletion = true;
            this.hitPlayer(obstacle);
            break;
          }
        }

        for (const star of this.stars) {
          if (star.markedForDeletion) continue;
          if (star.lane !== playerLane) continue;
          const dz = Math.abs(star.z - playerZ);
          if (dz > 5) continue;
          star.markedForDeletion = true;
          this.starCount += 1;
          this.combo = Math.min(6, this.combo + 1);
          this.comboTimer = 2.2;
          this.score += 60 * this.combo;
          this.spawnBurst(this.lanes[playerLane], 1.6, playerZ, "#ffe57a");
        }
      }

      hitPlayer(obstacle) {
        if (this.player.invuln > 0) return;
        this.player.invuln = 0.8;
        this.shield = Math.max(0, this.shield - 34);
        this.combo = 1;
        this.comboTimer = 0;
        this.shakeTime = 0.25;
        this.shakeAmp = 6;
        this.flashTime = 0.15;
        this.spawnBurst(this.lanes[obstacle.lane], 0.6, obstacle.z, "#ff8b6b");
        if (this.shield <= 0) this.gameOver();
      }

      updateUI() {
        this.ui.score.textContent = `SCORE: ${Math.floor(this.score)}`;
        this.ui.speed.textContent = `SPEED: ${Math.floor(this.speed)}`;
        this.ui.combo.textContent = `COMBO x${this.combo}`;
        this.ui.stars.textContent = `STARS: ${this.starCount}`;

        const shieldPct = Math.floor(this.shield);
        this.ui.shieldLabel.textContent = `SHIELD ${shieldPct}%`;
        this.ui.shieldFill.style.width = `${shieldPct}%`;
        this.ui.shieldFill.classList.toggle("low", shieldPct <= 30);
      }

      renderBackground() {
        const ctx = this.ctx;

        const grad = ctx.createLinearGradient(0, 0, 0, VIEW.height);
        grad.addColorStop(0, "#7fc9ff");
        grad.addColorStop(0.58, "#9fe0ff");
        grad.addColorStop(1, "#ffe5b5");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, VIEW.width, VIEW.height);

        ctx.fillStyle = "rgba(255, 233, 183, 0.9)";
        ctx.beginPath();
        ctx.arc(90, 90, 50, 0, Math.PI * 2);
        ctx.fill();

        for (const cloud of this.clouds) {
          ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
          ctx.beginPath();
          ctx.ellipse(cloud.x, cloud.y, 38 * cloud.scale, 20 * cloud.scale, 0, 0, Math.PI * 2);
          ctx.ellipse(cloud.x + 28 * cloud.scale, cloud.y + 6 * cloud.scale, 32 * cloud.scale, 18 * cloud.scale, 0, 0, Math.PI * 2);
          ctx.ellipse(cloud.x - 26 * cloud.scale, cloud.y + 8 * cloud.scale, 30 * cloud.scale, 16 * cloud.scale, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        const skylineY = projectPoint(0, 0, 200).y - 6;
        for (const building of this.buildings) {
          ctx.fillStyle = building.color;
          ctx.fillRect(building.x, skylineY - building.height, building.width, building.height);
          ctx.fillStyle = "rgba(255, 255, 255, 0.12)";
          ctx.fillRect(building.x + 6, skylineY - building.height + 8, building.width * 0.2, building.height * 0.6);
        }
      }

      renderRoad() {
        const ctx = this.ctx;
        const roadTopY = projectPoint(0, 0, 200).y;
        const roadBottomY = VIEW.height + 40;
        const roadTopW = 170;
        const roadBottomW = 540;

        ctx.fillStyle = "#49566b";
        ctx.beginPath();
        ctx.moveTo(VIEW.centerX - roadTopW / 2, roadTopY);
        ctx.lineTo(VIEW.centerX + roadTopW / 2, roadTopY);
        ctx.lineTo(VIEW.centerX + roadBottomW / 2, roadBottomY);
        ctx.lineTo(VIEW.centerX - roadBottomW / 2, roadBottomY);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#2e3848";
        ctx.lineWidth = 6;
        ctx.stroke();

        const edgeOffset = 16;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.25)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(VIEW.centerX - roadTopW / 2 + edgeOffset, roadTopY + 4);
        ctx.lineTo(VIEW.centerX - roadBottomW / 2 + edgeOffset, roadBottomY - 12);
        ctx.moveTo(VIEW.centerX + roadTopW / 2 - edgeOffset, roadTopY + 4);
        ctx.lineTo(VIEW.centerX + roadBottomW / 2 - edgeOffset, roadBottomY - 12);
        ctx.stroke();

        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 14]);
        for (const z of this.laneMarkers) {
          const projection = projectPoint(0, 0, z + 20);
          const markerHeight = 30 * projection.scale;
          ctx.beginPath();
          ctx.moveTo(projection.x, projection.y - markerHeight);
          ctx.lineTo(projection.x, projection.y + markerHeight);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, VIEW.width, VIEW.height);

        this.renderBackground();
        this.renderRoad();

        const renderables = [...this.stars, ...this.obstacles].sort((a, b) => b.z - a.z);
        renderables.forEach((entity) => entity.render(ctx, this));
        this.player.render(ctx, this);
        this.particles.forEach((particle) => particle.render(ctx));

        if (this.flashTime > 0) {
          ctx.fillStyle = `rgba(255, 163, 120, ${this.flashTime * 2})`;
          ctx.fillRect(0, 0, VIEW.width, VIEW.height);
        }
      }

      loop(timestamp) {
        const dt = Math.min(0.1, (timestamp - this.lastTime) / 1000);
        this.lastTime = timestamp;
        this.update(dt);

        if (this.shakeTime > 0) {
          const shakeX = randRange(-this.shakeAmp, this.shakeAmp);
          const shakeY = randRange(-this.shakeAmp, this.shakeAmp);
          this.ctx.save();
          this.ctx.translate(shakeX, shakeY);
          this.render();
          this.ctx.restore();
        } else {
          this.render();
        }

        this.input.endFrame();
        requestAnimationFrame((t) => this.loop(t));
      }
    }

    /**
     * 5. INITIALIZATION
     */
    window.addEventListener("load", () => {
      const canvas = document.getElementById("gameCanvas");
      new Game(canvas);
    });
  </script>
</body>
</html>
