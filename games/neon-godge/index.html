<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon godge</title>
  <style>
    :root {
      --neon-cyan: #36f9ff;
      --neon-pink: #ff4fd8;
      --neon-purple: #7f5bff;
      --deep-space: #0b0f1d;
      --panel: rgba(9, 13, 29, 0.88);
      --text-bright: #f6f7ff;
      --text-dim: #b7c2e6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #1c2143 0%, #0b0f1d 45%, #05060f 100%);
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", "Lucida Sans", sans-serif;
      overflow: hidden;
      color: var(--text-bright);
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        linear-gradient(120deg, rgba(127, 91, 255, 0.1), transparent 50%),
        repeating-linear-gradient(90deg, rgba(54, 249, 255, 0.06), rgba(54, 249, 255, 0.06) 1px, transparent 1px, transparent 80px);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    #game-container {
      position: relative;
      box-shadow: 0 18px 50px rgba(10, 16, 36, 0.6), 0 0 30px rgba(54, 249, 255, 0.2);
      border: 2px solid rgba(127, 91, 255, 0.6);
      border-radius: 12px;
      overflow: hidden;
    }

    canvas {
      display: block;
      background: radial-gradient(circle at top right, rgba(127, 91, 255, 0.25), transparent 55%),
        linear-gradient(180deg, #0e152e, #0c1224 55%, #0a0e1d);
      touch-action: none;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      font-size: 18px;
      text-shadow: 0 0 8px rgba(54, 249, 255, 0.55);
    }

    .hud span {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(8, 12, 24, 0.6);
      border: 1px solid rgba(54, 249, 255, 0.3);
    }

    #start-screen,
    #game-over-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      text-align: center;
      background: var(--panel);
      backdrop-filter: blur(4px);
      pointer-events: auto;
    }

    h1 {
      margin: 0;
      font-size: 46px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--neon-cyan);
      text-shadow: 0 0 18px rgba(54, 249, 255, 0.8);
    }

    p {
      margin: 0;
      font-size: 18px;
      color: var(--text-dim);
    }

    button {
      margin-top: 16px;
      padding: 12px 28px;
      font-size: 18px;
      font-weight: 700;
      border: none;
      border-radius: 999px;
      background: linear-gradient(120deg, var(--neon-pink), var(--neon-purple));
      color: #fff;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(255, 79, 216, 0.6);
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>

    <div id="ui-layer">
      <div class="hud">
        <span id="score-display">Score: 0</span>
        <span id="status-display">Length: 4</span>
        <span id="speed-display">Speed: 6.0</span>
      </div>

      <div id="start-screen">
        <h1>Neon Godge</h1>
        <p>Eat the neon orbs, grow longer, and dodge the walls or your own tail.</p>
        <p>Controls: Arrow Keys or WASD. Swipe on touch screens to steer.</p>
        <p>Press Enter/Space or click PLAY to start.</p>
        <button id="start-btn">PLAY</button>
      </div>

      <div id="game-over-screen" class="hidden">
        <h1>Game Over</h1>
        <p id="final-score">Score: 0</p>
        <p id="best-score">Best: 0</p>
        <p>Press Enter/Space or click RESTART.</p>
        <button id="restart-btn">RESTART</button>
      </div>
    </div>
  </div>

  <script>
    /**
     * 1. UTILITY CLASSES
     */
    class InputManager {
      constructor(canvas) {
        this.keys = {};
        this.pressed = {};
        this.down = {};
        this.pointerStart = null;
        this.swipeDir = null;

        window.addEventListener("keydown", (e) => {
          this.keys[e.code] = true;
          if (!this.down[e.code]) {
            this.pressed[e.code] = true;
            this.down[e.code] = true;
          }
        });

        window.addEventListener("keyup", (e) => {
          this.keys[e.code] = false;
          this.down[e.code] = false;
          this.pressed[e.code] = false;
        });

        canvas.addEventListener(
          "pointerdown",
          (e) => {
            this.pointerStart = { x: e.clientX, y: e.clientY };
          },
          { passive: true }
        );

        canvas.addEventListener(
          "pointerup",
          (e) => {
            if (!this.pointerStart) return;
            const dx = e.clientX - this.pointerStart.x;
            const dy = e.clientY - this.pointerStart.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 20) {
              if (Math.abs(dx) > Math.abs(dy)) {
                this.swipeDir = { x: Math.sign(dx), y: 0 };
              } else {
                this.swipeDir = { x: 0, y: Math.sign(dy) };
              }
            }
            this.pointerStart = null;
          },
          { passive: true }
        );
      }

      isDown(code) {
        return !!this.keys[code];
      }

      isPressed(code) {
        return !!this.pressed[code];
      }

      consumeSwipeDirection() {
        const dir = this.swipeDir;
        this.swipeDir = null;
        return dir;
      }

      endFrame() {
        for (const code in this.pressed) {
          this.pressed[code] = false;
        }
      }
    }

    /**
     * 2. BASE GAME OBJECT
     */
    class GameObject {
      constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.markedForDeletion = false;
      }

      update(dt) {}
      render(ctx) {}
    }

    /**
     * 3. GAME ENTITIES
     */
    class Food extends GameObject {
      constructor(gridX, gridY, cell) {
        super(gridX * cell, gridY * cell, cell, cell);
        this.gridX = gridX;
        this.gridY = gridY;
        this.cell = cell;
        this.pulse = 0;
      }

      update(dt) {
        this.pulse += dt * 4;
      }

      render(ctx) {
        const glow = 6 + Math.sin(this.pulse) * 2;
        ctx.save();
        ctx.shadowColor = "rgba(255, 79, 216, 0.9)";
        ctx.shadowBlur = glow;
        ctx.fillStyle = "#ffb3f4";
        ctx.beginPath();
        ctx.arc(this.x + this.cell / 2, this.y + this.cell / 2, this.cell * 0.32, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class Particle extends GameObject {
      constructor(x, y, color) {
        super(x, y, 3, 3);
        this.vx = (Math.random() - 0.5) * 160;
        this.vy = (Math.random() - 0.5) * 160;
        this.life = 1.0;
        this.color = color;
      }

      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt * 2.2;
        if (this.life <= 0) this.markedForDeletion = true;
      }

      render(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.globalAlpha = 1;
      }
    }

    class Snake extends GameObject {
      constructor(cols, rows, cell) {
        super(0, 0, cols * cell, rows * cell);
        this.cols = cols;
        this.rows = rows;
        this.cell = cell;
        this.reset();
      }

      reset() {
        const startX = Math.floor(this.cols / 2);
        const startY = Math.floor(this.rows / 2);
        this.segments = [];
        this.direction = { x: 1, y: 0 };
        this.pendingDirection = { x: 1, y: 0 };
        this.growSegments = 0;

        for (let i = 0; i < 4; i++) {
          this.segments.push({ x: startX - i, y: startY });
        }
      }

      setDirection(dir) {
        if (!dir) return;
        const { x, y } = dir;
        if (x === 0 && y === 0) return;
        if (x === -this.direction.x && y === -this.direction.y) return;
        this.pendingDirection = { x, y };
      }

      step() {
        this.direction = { ...this.pendingDirection };
        const head = this.segments[0];
        const next = { x: head.x + this.direction.x, y: head.y + this.direction.y };
        this.segments.unshift(next);
        if (this.growSegments > 0) {
          this.growSegments -= 1;
        } else {
          this.segments.pop();
        }
      }

      grow(amount) {
        this.growSegments += amount;
      }

      hitsSelf() {
        const head = this.segments[0];
        for (let i = 1; i < this.segments.length; i++) {
          const seg = this.segments[i];
          if (seg.x === head.x && seg.y === head.y) return true;
        }
        return false;
      }

      hitsWall() {
        const head = this.segments[0];
        return head.x < 0 || head.y < 0 || head.x >= this.cols || head.y >= this.rows;
      }

      occupies(x, y) {
        return this.segments.some((seg) => seg.x === x && seg.y === y);
      }

      render(ctx) {
        ctx.save();
        ctx.shadowColor = "rgba(54, 249, 255, 0.7)";
        ctx.shadowBlur = 12;
        for (let i = this.segments.length - 1; i >= 0; i--) {
          const seg = this.segments[i];
          const isHead = i === 0;
          ctx.fillStyle = isHead ? "#36f9ff" : "rgba(54, 249, 255, 0.55)";
          ctx.fillRect(seg.x * this.cell + 1, seg.y * this.cell + 1, this.cell - 2, this.cell - 2);
        }
        ctx.restore();

        const head = this.segments[0];
        ctx.fillStyle = "#0b0f1d";
        ctx.beginPath();
        ctx.arc(head.x * this.cell + this.cell * 0.3, head.y * this.cell + this.cell * 0.35, 2.5, 0, Math.PI * 2);
        ctx.arc(head.x * this.cell + this.cell * 0.65, head.y * this.cell + this.cell * 0.35, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    /**
     * 4. GAME MANAGER
     */
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.width = canvas.width;
        this.height = canvas.height;
        this.cell = 20;
        this.cols = Math.floor(this.width / this.cell);
        this.rows = Math.floor(this.height / this.cell);
        this.input = new InputManager(canvas);

        this.ui = {
          start: document.getElementById("start-screen"),
          over: document.getElementById("game-over-screen"),
          score: document.getElementById("score-display"),
          status: document.getElementById("status-display"),
          speed: document.getElementById("speed-display"),
          finalScore: document.getElementById("final-score"),
          bestScore: document.getElementById("best-score")
        };

        document.getElementById("start-btn").addEventListener("click", () => this.start());
        document.getElementById("restart-btn").addEventListener("click", () => this.start());
        window.addEventListener("keydown", (e) => {
          if ((e.code === "Space" || e.code === "Enter") && !this.isRunning) {
            this.start();
          }
        });

        this.lastTime = 0;
        this.isRunning = false;
        this.bestScore = Number(localStorage.getItem("neon-godge-best")) || 0;
        this.reset();
      }

      reset() {
        this.snake = new Snake(this.cols, this.rows, this.cell);
        this.food = this.spawnFood();
        this.particles = [];
        this.score = 0;
        this.baseSpeed = 6;
        this.speed = this.baseSpeed;
        this.stepTimer = 0;
        this.flashTimer = 0;
        this.updateUI();
      }

      start() {
        this.reset();
        this.ui.start.classList.add("hidden");
        this.ui.over.classList.add("hidden");
        if (!this.isRunning) {
          this.isRunning = true;
          this.lastTime = performance.now();
          requestAnimationFrame((t) => this.loop(t));
        }
      }

      updateUI() {
        this.ui.score.textContent = `Score: ${this.score}`;
        this.ui.status.textContent = `Length: ${this.snake.segments.length}`;
        this.ui.speed.textContent = `Speed: ${this.speed.toFixed(1)}`;
      }

      spawnFood() {
        let x = 0;
        let y = 0;
        let attempts = 0;
        do {
          x = Math.floor(Math.random() * this.cols);
          y = Math.floor(Math.random() * this.rows);
          attempts += 1;
        } while (this.snake && this.snake.occupies(x, y) && attempts < 200);

        return new Food(x, y, this.cell);
      }

      handleInput() {
        const swipe = this.input.consumeSwipeDirection();
        if (swipe) {
          this.snake.setDirection(swipe);
        }

        if (this.input.isPressed("ArrowUp") || this.input.isPressed("KeyW")) {
          this.snake.setDirection({ x: 0, y: -1 });
        } else if (this.input.isPressed("ArrowDown") || this.input.isPressed("KeyS")) {
          this.snake.setDirection({ x: 0, y: 1 });
        } else if (this.input.isPressed("ArrowLeft") || this.input.isPressed("KeyA")) {
          this.snake.setDirection({ x: -1, y: 0 });
        } else if (this.input.isPressed("ArrowRight") || this.input.isPressed("KeyD")) {
          this.snake.setDirection({ x: 1, y: 0 });
        }
      }

      update(dt) {
        if (!this.isRunning) return;

        this.handleInput();
        this.food.update(dt);

        this.stepTimer += dt;
        const stepInterval = 1 / this.speed;
        while (this.stepTimer >= stepInterval) {
          this.stepTimer -= stepInterval;
          this.snake.step();

          if (this.snake.hitsWall() || this.snake.hitsSelf()) {
            this.gameOver();
            break;
          }

          const head = this.snake.segments[0];
          if (head.x === this.food.gridX && head.y === this.food.gridY) {
            this.score += 10;
            this.snake.grow(2);
            this.speed = Math.min(14, this.baseSpeed + this.score / 60);
            this.flashTimer = 0.2;
            this.spawnParticles(head.x * this.cell + this.cell / 2, head.y * this.cell + this.cell / 2);
            this.food = this.spawnFood();
          }
        }

        if (this.flashTimer > 0) this.flashTimer -= dt;

        this.particles.forEach((p) => p.update(dt));
        this.particles = this.particles.filter((p) => !p.markedForDeletion);

        this.input.endFrame();
        this.updateUI();
      }

      spawnParticles(x, y) {
        for (let i = 0; i < 18; i++) {
          this.particles.push(new Particle(x, y, "#ff4fd8"));
        }
      }

      gameOver() {
        this.isRunning = false;
        if (this.score > this.bestScore) {
          this.bestScore = this.score;
          localStorage.setItem("neon-godge-best", String(this.bestScore));
        }
        this.ui.finalScore.textContent = `Score: ${this.score}`;
        this.ui.bestScore.textContent = `Best: ${this.bestScore}`;
        this.ui.over.classList.remove("hidden");
      }

      renderBackground() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = "rgba(255, 255, 255, 0.04)";
        for (let x = 0; x < this.width; x += this.cell) {
          this.ctx.fillRect(x, 0, 1, this.height);
        }
        for (let y = 0; y < this.height; y += this.cell) {
          this.ctx.fillRect(0, y, this.width, 1);
        }
      }

      render() {
        this.renderBackground();
        this.food.render(this.ctx);
        this.snake.render(this.ctx);
        this.particles.forEach((p) => p.render(this.ctx));

        if (this.flashTimer > 0) {
          this.ctx.fillStyle = `rgba(255, 79, 216, ${this.flashTimer * 1.2})`;
          this.ctx.fillRect(0, 0, this.width, this.height);
        }
      }

      loop(timestamp) {
        if (!this.isRunning) return;
        const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
        this.lastTime = timestamp;
        this.update(dt);
        this.render();
        requestAnimationFrame((t) => this.loop(t));
      }
    }

    /**
     * 5. INITIALIZATION
     */
    window.onload = () => {
      const canvas = document.getElementById("gameCanvas");
      new Game(canvas);
      // Starts on the start screen; click PLAY to begin.
    };
  </script>
</body>
</html>
