<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Geometry Dash 3D - Neon Run</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600;700&display=swap");

      :root {
        --bg-0: #090317;
        --bg-1: #1b0c3a;
        --bg-2: #270f4f;
        --panel: rgba(10, 6, 26, 0.78);
        --text: #f7eaff;
        --accent: #ff7ad9;
        --accent-2: #62f3ff;
        --danger: #ff4d6d;
        --success: #6bffb5;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background:
          radial-gradient(circle at 15% 18%, #4c1a7f 0%, transparent 45%),
          radial-gradient(circle at 85% 12%, #1d6cb0 0%, transparent 40%),
          linear-gradient(160deg, var(--bg-2), var(--bg-0));
        color: var(--text);
        font-family: "Oxanium", "Trebuchet MS", sans-serif;
        overflow: hidden;
      }

      #game-shell {
        position: relative;
        width: min(94vw, 980px);
        aspect-ratio: 16 / 9;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 14px;
        overflow: hidden;
        background: #000;
        box-shadow: 0 30px 90px rgba(0, 0, 0, 0.55);
      }

      #render-layer,
      #ui-layer,
      #fx-layer {
        position: absolute;
        inset: 0;
      }

      #render-layer canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #ui-layer {
        pointer-events: none;
      }

      #fx-layer {
        pointer-events: none;
        background:
          linear-gradient(transparent 92%, rgba(255, 122, 217, 0.2) 100%),
          repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.05) 0 1px, transparent 1px 3px);
        mix-blend-mode: screen;
        opacity: 0.35;
      }

      .hud {
        position: absolute;
        top: 14px;
        left: 14px;
        right: 14px;
        display: flex;
        justify-content: space-between;
        gap: 12px;
        font-size: 16px;
        font-weight: 700;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.7);
        letter-spacing: 0.08em;
      }

      .hud-block {
        display: grid;
        gap: 6px;
      }

      #progress-bar {
        width: 220px;
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.16);
        overflow: hidden;
        box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4);
      }

      #progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
      }

      #start-screen,
      #game-over-screen,
      #win-screen,
      #unsupported-screen {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        background: var(--panel);
        padding: 24px;
        pointer-events: auto;
      }

      .panel {
        max-width: 620px;
        display: grid;
        gap: 12px;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 4vw, 3.2rem);
        letter-spacing: 0.14em;
        text-transform: uppercase;
      }

      h2 {
        margin: 0;
        font-size: 1.4rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      p {
        margin: 0;
        color: #e5cfff;
        line-height: 1.4;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 14px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.08);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      button {
        justify-self: center;
        margin-top: 6px;
        padding: 12px 28px;
        border: 0;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
        color: #160a2b;
        font-weight: 800;
        font-size: 1rem;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="game-shell">
      <div id="render-layer"></div>
      <div id="fx-layer"></div>
      <div id="ui-layer">
        <div class="hud">
          <div class="hud-block">
            <div id="score-text">DIST: 0m</div>
            <div id="attempt-text">ATTEMPT: 1</div>
          </div>
          <div class="hud-block" style="text-align: right; align-items: end;">
            <div id="hp-text">HP: 1</div>
            <div id="progress-text">PROGRESS: 0%</div>
            <div id="progress-bar"><div id="progress-fill"></div></div>
          </div>
        </div>

        <div id="start-screen">
          <div class="panel">
            <div class="pill">VAPORWAVE RUN</div>
            <h1>Geometry Dash 3D</h1>
            <p>Auto-run forward and time your jumps to clear spikes, blocks, and saws.</p>
            <p>Controls: Space / W / Up Arrow or Click/Tap to jump. Hit pads for a boosted leap.</p>
            <button id="start-btn" type="button">Start Run</button>
          </div>
        </div>

        <div id="game-over-screen" class="hidden">
          <div class="panel">
            <h2>Game Over</h2>
            <p id="final-score">Distance: 0m</p>
            <p>Tap to try again and finish the level.</p>
            <button id="restart-btn" type="button">Retry</button>
          </div>
        </div>

        <div id="win-screen" class="hidden">
          <div class="panel">
            <h2>Level Complete</h2>
            <p id="win-score">Distance: 0m</p>
            <p>Clean run! Want to push for a faster finish?</p>
            <button id="win-restart-btn" type="button">Play Again</button>
          </div>
        </div>

        <div id="unsupported-screen" class="hidden">
          <div class="panel">
            <h2>WebGL Unavailable</h2>
            <p>This browser could not initialize WebGL. Try a modern browser with GPU support.</p>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

      /**
       * 1. UTILITY CLASSES
       */
      class InputManager {
        constructor() {
          this.down = {};
          this.pressed = {};
          this.pointerDown = false;
          this.pointerPressed = false;

          window.addEventListener("keydown", (event) => {
            const code = event.code;
            if (!this.down[code]) this.pressed[code] = true;
            this.down[code] = true;
          });
          window.addEventListener("keyup", (event) => {
            const code = event.code;
            this.down[code] = false;
            this.pressed[code] = false;
          });
          window.addEventListener("blur", () => {
            this.down = {};
            this.pressed = {};
            this.pointerDown = false;
            this.pointerPressed = false;
          });
          window.addEventListener("pointerdown", () => {
            if (!this.pointerDown) this.pointerPressed = true;
            this.pointerDown = true;
          });
          window.addEventListener("pointerup", () => {
            this.pointerDown = false;
          });
        }

        isDown(code) {
          return !!this.down[code];
        }

        isPressed(code) {
          return !!this.pressed[code];
        }

        isJumpPressed() {
          return (
            this.isPressed("Space") ||
            this.isPressed("ArrowUp") ||
            this.isPressed("KeyW") ||
            this.pointerPressed
          );
        }

        endFrame() {
          for (const key in this.pressed) this.pressed[key] = false;
          this.pointerPressed = false;
        }
      }

      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

      function disposeMesh(mesh) {
        if (!mesh) return;
        if (mesh.geometry) mesh.geometry.dispose();
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach((mat) => mat.dispose());
        } else if (mesh.material) {
          mesh.material.dispose();
        }
      }

      function aabbIntersect(aPos, aHalf, bPos, bHalf) {
        return (
          Math.abs(aPos.x - bPos.x) < aHalf.x + bHalf.x &&
          Math.abs(aPos.y - bPos.y) < aHalf.y + bHalf.y &&
          Math.abs(aPos.z - bPos.z) < aHalf.z + bHalf.z
        );
      }

      /**
       * 2. BASE ENTITY CLASS
       */
      class Entity {
        constructor(mesh) {
          this.mesh = mesh;
          this.markedForDeletion = false;
        }

        update(_dt, _game) {}

        destroy() {
          disposeMesh(this.mesh);
        }
      }

      /**
       * 3. GAME ENTITIES
       */
      class Player extends Entity {
        constructor(groundY) {
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshStandardMaterial({
            color: 0x7bf7ff,
            emissive: 0x1f5e7a,
            roughness: 0.25,
            metalness: 0.2
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(0, groundY + 0.5, 6.5);
          super(mesh);

          this.groundY = groundY;
          this.velocityY = 0;
          this.onGround = true;
          this.half = new THREE.Vector3(0.45, 0.45, 0.45);
          this.rotationTarget = 0;
        }

        reset() {
          this.mesh.position.set(0, this.groundY + 0.5, 6.5);
          this.velocityY = 0;
          this.onGround = true;
          this.mesh.rotation.set(0, 0, 0);
          this.rotationTarget = 0;
        }

        applyJump(velocity) {
          this.velocityY = velocity;
          this.onGround = false;
        }

        update(dt, game) {
          this.velocityY += game.gravity * dt;
          this.mesh.position.y += this.velocityY * dt;

          if (this.mesh.position.y <= this.groundY + 0.5) {
            this.mesh.position.y = this.groundY + 0.5;
            this.velocityY = 0;
            this.onGround = true;
          } else {
            this.onGround = false;
          }

          if (!this.onGround) {
            this.mesh.rotation.z += dt * 6.2;
          } else {
            const snapped = Math.round(this.mesh.rotation.z / (Math.PI / 2)) * (Math.PI / 2);
            this.mesh.rotation.z += (snapped - this.mesh.rotation.z) * Math.min(1, dt * 8);
          }
        }
      }

      class Obstacle extends Entity {
        constructor(config, groundY) {
          const { type, width = 1.2, height = 1.2, depth = 1.2 } = config;
          let geometry;
          let material;
          let mesh;

          if (type === "spike") {
            geometry = new THREE.ConeGeometry(0.7, 1.3, 4);
            material = new THREE.MeshStandardMaterial({
              color: 0xff4d6d,
              emissive: 0x420b1a,
              roughness: 0.3,
              metalness: 0.1
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.y = Math.PI / 4;
            mesh.position.set(0, groundY + 0.65, config.z);
            super(mesh);
            this.half = new THREE.Vector3(0.5, 0.7, 0.5);
          } else if (type === "pad") {
            geometry = new THREE.BoxGeometry(1.6, 0.25, 1.6);
            material = new THREE.MeshStandardMaterial({
              color: 0x6bffb5,
              emissive: 0x1a5f44,
              roughness: 0.4,
              metalness: 0.1
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, groundY + 0.125, config.z);
            super(mesh);
            this.half = new THREE.Vector3(0.8, 0.2, 0.8);
            this.used = false;
          } else if (type === "saw") {
            geometry = new THREE.CylinderGeometry(0.7, 0.7, 0.2, 12);
            material = new THREE.MeshStandardMaterial({
              color: 0xffc857,
              emissive: 0x5c2b00,
              roughness: 0.35,
              metalness: 0.4
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.set(0, groundY + 0.9, config.z);
            super(mesh);
            this.half = new THREE.Vector3(0.7, 0.7, 0.7);
            this.bobSeed = Math.random() * Math.PI * 2;
          } else {
            geometry = new THREE.BoxGeometry(width, height, depth);
            material = new THREE.MeshStandardMaterial({
              color: 0x6a5bff,
              emissive: 0x20145f,
              roughness: 0.35,
              metalness: 0.15
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, groundY + height / 2, config.z);
            super(mesh);
            this.half = new THREE.Vector3(width / 2, height / 2, depth / 2);
          }

          this.type = type;
          this.speed = config.speed || 0;
        }

        update(dt, game) {
          this.mesh.position.z += game.speed * dt;
          if (this.type === "saw") {
            this.mesh.rotation.z += dt * 7;
            this.mesh.position.y = game.groundY + 0.9 + Math.sin(game.time * 3 + this.bobSeed) * 0.3;
          }
          if (this.mesh.position.z > 12) this.markedForDeletion = true;
        }
      }

      class Particle extends Entity {
        constructor(position, color) {
          const geometry = new THREE.SphereGeometry(0.12, 8, 8);
          const material = new THREE.MeshStandardMaterial({
            color,
            emissive: color,
            emissiveIntensity: 0.7
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.copy(position);
          super(mesh);

          this.velocity = new THREE.Vector3(
            (Math.random() * 2 - 1) * 5,
            Math.random() * 4 + 2,
            (Math.random() * 2 - 1) * 5
          );
          this.life = 0.7;
        }

        update(dt) {
          this.life -= dt;
          this.mesh.position.addScaledVector(this.velocity, dt);
          this.velocity.y -= dt * 10;
          this.mesh.scale.setScalar(Math.max(0.01, this.life));
          if (this.life <= 0) this.markedForDeletion = true;
        }
      }

      /**
       * 4. GAME MANAGER
       */
      class Game {
        constructor(root) {
          this.root = root;
          this.renderLayer = document.getElementById("render-layer");
          this.input = new InputManager();
          this.state = "START";
          this.lastTime = 0;
          this.time = 0;

          this.ui = {
            score: document.getElementById("score-text"),
            attempt: document.getElementById("attempt-text"),
            hp: document.getElementById("hp-text"),
            progress: document.getElementById("progress-text"),
            progressFill: document.getElementById("progress-fill"),
            final: document.getElementById("final-score"),
            winScore: document.getElementById("win-score"),
            start: document.getElementById("start-screen"),
            over: document.getElementById("game-over-screen"),
            win: document.getElementById("win-screen"),
            unsupported: document.getElementById("unsupported-screen"),
            startBtn: document.getElementById("start-btn"),
            restartBtn: document.getElementById("restart-btn"),
            winRestartBtn: document.getElementById("win-restart-btn")
          };

          this.ui.startBtn.addEventListener("click", () => this.start());
          this.ui.restartBtn.addEventListener("click", () => this.start());
          this.ui.winRestartBtn.addEventListener("click", () => this.start());
          window.addEventListener("keydown", (event) => {
            if ((event.code === "Space" || event.code === "Enter") && this.state === "START") {
              this.start();
            }
          });

          this.groundY = 0;
          this.gravity = -32;
          this.jumpVelocity = 12.8;
          this.padVelocity = 17.5;
          this.baseSpeed = 16;
          this.maxSpeed = 28;
          this.speedRamp = 0.2;
          this.levelLength = 950;
          this.spawnAhead = 130;

          this.attempts = 0;
          this.score = 0;
          this.hp = 1;
          this.distance = 0;
          this.speed = this.baseSpeed;
          this.jumpBuffer = 0;
          this.jumpBufferTime = 0.14;
          this.coyoteTime = 0.12;
          this.coyoteTimer = 0;
          this.flashTime = 0;
          this.shakeTime = 0;

          this.obstacles = [];
          this.particles = [];
          this.floorTiles = [];
          this.level = [];
          this.nextSpawnIndex = 0;

          this.setupThree();
          this.setupWorld();
          this.buildLevel();
          this.handleResize();
          window.addEventListener("resize", () => this.handleResize());

          window.__TEST__ = {
            ready: true,
            state: () => ({
              mode: this.state,
              distance: Math.floor(this.distance),
              hp: this.hp,
              obstacles: this.obstacles.length
            })
          };
        }

        setupThree() {
          const testCanvas = document.createElement("canvas");
          const gl = testCanvas.getContext("webgl2") || testCanvas.getContext("webgl");
          if (!gl) {
            this.ui.unsupported.classList.remove("hidden");
            throw new Error("WebGL unavailable");
          }

          this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          this.renderer.shadowMap.enabled = false;
          this.renderLayer.appendChild(this.renderer.domElement);

          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x100820);
          this.scene.fog = new THREE.Fog(0x100820, 18, 110);

          this.camera = new THREE.PerspectiveCamera(62, 16 / 9, 0.1, 180);
          this.camera.position.set(0, 4.8, 12);
          this.camera.lookAt(0, 1.6, 0);
        }

        setupWorld() {
          const hemi = new THREE.HemisphereLight(0xa5c9ff, 0x110b2b, 0.9);
          this.scene.add(hemi);

          const key = new THREE.DirectionalLight(0xffffff, 1.1);
          key.position.set(6, 12, 8);
          this.scene.add(key);

          const accent = new THREE.PointLight(0xff7ad9, 0.8, 40, 2);
          accent.position.set(-4, 6, 4);
          this.scene.add(accent);

          const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x201436,
            emissive: 0x180f2f,
            roughness: 0.85
          });

          for (let i = 0; i < 28; i++) {
            const tile = new THREE.Mesh(new THREE.BoxGeometry(8, 0.2, 6), floorMaterial);
            tile.position.set(0, this.groundY - 0.1, -i * 6);
            this.floorTiles.push(tile);
            this.scene.add(tile);
          }

          const railMaterial = new THREE.MeshStandardMaterial({
            color: 0x62f3ff,
            emissive: 0x1f7da8,
            roughness: 0.2,
            metalness: 0.2
          });
          this.rails = [];
          for (let i = 0; i < 36; i++) {
            const rail = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 3.2), railMaterial);
            rail.position.set(2.5, this.groundY + 0.12, -i * 5);
            this.rails.push(rail);
            this.scene.add(rail);

            const rail2 = rail.clone();
            rail2.position.x = -2.5;
            this.rails.push(rail2);
            this.scene.add(rail2);
          }

          const glowRing = new THREE.Mesh(
            new THREE.TorusGeometry(6, 0.06, 8, 60),
            new THREE.MeshStandardMaterial({
              color: 0xff7ad9,
              emissive: 0x43102f,
              roughness: 0.2,
              metalness: 0.6
            })
          );
          glowRing.position.set(0, 3.5, -40);
          glowRing.rotation.x = Math.PI / 2.6;
          this.scene.add(glowRing);

          this.player = new Player(this.groundY);
          this.scene.add(this.player.mesh);
          this.reset();
        }

        buildLevel() {
          this.level = [];
          const add = (distance, type, opts = {}) => {
            this.level.push({ distance, type, ...opts });
          };
          const spikes = (start, gap, count) => {
            for (let i = 0; i < count; i++) add(start + i * gap, "spike");
          };

          spikes(24, 10, 3);
          add(60, "block", { height: 1.6, width: 1.4, depth: 1.4 });
          spikes(86, 8, 4);
          add(120, "pad");
          spikes(132, 12, 3);
          add(168, "block", { height: 2.2, width: 1.5, depth: 1.6 });
          spikes(210, 9, 5);
          add(260, "saw");
          spikes(290, 8, 6);
          add(340, "pad");
          spikes(354, 10, 4);
          add(400, "block", { height: 1.8, width: 1.8, depth: 1.5 });
          add(430, "saw");
          spikes(460, 9, 6);
          add(520, "pad");
          spikes(536, 8, 5);
          add(590, "block", { height: 2.1, width: 1.6, depth: 1.6 });
          spikes(640, 8, 6);
          add(690, "saw");
          spikes(720, 7, 7);
          add(770, "pad");
          spikes(784, 8, 6);
          add(840, "block", { height: 2.4, width: 1.8, depth: 1.7 });
          spikes(880, 8, 5);

          this.level.sort((a, b) => a.distance - b.distance);
          this.nextSpawnIndex = 0;
        }

        handleResize() {
          const width = this.root.clientWidth;
          const height = this.root.clientHeight;
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(width, height, false);
        }

        reset() {
          this.score = 0;
          this.hp = 1;
          this.distance = 0;
          this.speed = this.baseSpeed;
          this.jumpBuffer = 0;
          this.coyoteTimer = 0;
          this.flashTime = 0;
          this.shakeTime = 0;
          this.time = 0;

          this.player.reset();

          this.obstacles.forEach((item) => {
            this.scene.remove(item.mesh);
            item.destroy();
          });
          this.particles.forEach((item) => {
            this.scene.remove(item.mesh);
            item.destroy();
          });
          this.obstacles = [];
          this.particles = [];
          this.nextSpawnIndex = 0;
          this.updateUI();
        }

        start() {
          if (this.state === "PLAYING") return;
          this.reset();
          this.attempts += 1;
          this.state = "PLAYING";
          this.ui.start.classList.add("hidden");
          this.ui.over.classList.add("hidden");
          this.ui.win.classList.add("hidden");
          this.lastTime = performance.now();
          requestAnimationFrame((timestamp) => this.loop(timestamp));
        }

        endGame(win = false) {
          this.state = win ? "WIN" : "GAMEOVER";
          const text = `Distance: ${Math.floor(this.distance)}m`;
          if (win) {
            this.ui.winScore.textContent = text;
            this.ui.win.classList.remove("hidden");
          } else {
            this.ui.final.textContent = text;
            this.ui.over.classList.remove("hidden");
          }
        }

        spawnObstacle(config) {
          const obstacle = new Obstacle({ ...config, z: this.player.mesh.position.z - (config.distance - this.distance) }, this.groundY);
          this.obstacles.push(obstacle);
          this.scene.add(obstacle.mesh);
        }

        createBurst(position, color) {
          for (let i = 0; i < 14; i++) {
            const p = new Particle(position, color);
            this.particles.push(p);
            this.scene.add(p.mesh);
          }
        }

        update(dt) {
          if (this.state !== "PLAYING") return;

          this.time += dt;
          this.distance += this.speed * dt;
          this.speed = Math.min(this.maxSpeed, this.speed + dt * this.speedRamp);
          this.score = this.distance;

          if (this.input.isJumpPressed()) {
            this.jumpBuffer = this.jumpBufferTime;
          } else {
            this.jumpBuffer = Math.max(0, this.jumpBuffer - dt);
          }

          if (this.player.onGround) {
            this.coyoteTimer = this.coyoteTime;
          } else {
            this.coyoteTimer = Math.max(0, this.coyoteTimer - dt);
          }

          if (this.jumpBuffer > 0 && this.coyoteTimer > 0) {
            this.player.applyJump(this.jumpVelocity);
            this.jumpBuffer = 0;
            this.coyoteTimer = 0;
            this.shakeTime = 0.08;
            this.createBurst(this.player.mesh.position, 0x62f3ff);
          }

          this.player.update(dt, this);

          for (const tile of this.floorTiles) {
            tile.position.z += this.speed * dt;
            if (tile.position.z > 12) tile.position.z -= 168;
          }

          for (const rail of this.rails) {
            rail.position.z += this.speed * dt;
            if (rail.position.z > 12) rail.position.z -= 180;
          }

          while (
            this.nextSpawnIndex < this.level.length &&
            this.level[this.nextSpawnIndex].distance < this.distance + this.spawnAhead
          ) {
            this.spawnObstacle(this.level[this.nextSpawnIndex]);
            this.nextSpawnIndex += 1;
          }

          this.obstacles.forEach((item) => item.update(dt, this));
          this.particles.forEach((item) => item.update(dt, this));

          for (const obstacle of this.obstacles) {
            if (obstacle.markedForDeletion) continue;
            if (obstacle.type === "pad") {
              if (!obstacle.used && aabbIntersect(this.player.mesh.position, this.player.half, obstacle.mesh.position, obstacle.half)) {
                obstacle.used = true;
                this.player.applyJump(this.padVelocity);
                this.shakeTime = 0.12;
                this.createBurst(obstacle.mesh.position, 0x6bffb5);
              }
              continue;
            }

            if (aabbIntersect(this.player.mesh.position, this.player.half, obstacle.mesh.position, obstacle.half)) {
              this.hp = 0;
              this.flashTime = 0.18;
              this.shakeTime = 0.2;
              this.createBurst(this.player.mesh.position, 0xff4d6d);
              this.endGame(false);
              break;
            }
          }

          if (this.player.mesh.position.y < -4) {
            this.hp = 0;
            this.endGame(false);
          }

          if (this.distance >= this.levelLength) {
            this.endGame(true);
          }

          this.flashTime = Math.max(0, this.flashTime - dt);
          this.renderer.setClearColor(this.flashTime > 0 ? 0x2a0b1a : 0x100820, 1);

          this.cleanup(this.obstacles);
          this.cleanup(this.particles);
          this.updateUI();
        }

        cleanup(list) {
          for (let i = list.length - 1; i >= 0; i--) {
            const item = list[i];
            if (!item.markedForDeletion) continue;
            this.scene.remove(item.mesh);
            item.destroy();
            list.splice(i, 1);
          }
        }

        updateUI() {
          const progress = clamp(this.distance / this.levelLength, 0, 1);
          this.ui.score.textContent = `DIST: ${Math.floor(this.score)}m`;
          this.ui.attempt.textContent = `ATTEMPT: ${this.attempts || 1}`;
          this.ui.hp.textContent = `HP: ${this.hp}`;
          this.ui.progress.textContent = `PROGRESS: ${Math.floor(progress * 100)}%`;
          this.ui.progressFill.style.width = `${Math.floor(progress * 100)}%`;
        }

        loop(timestamp) {
          if (this.state !== "PLAYING") {
            this.render();
            return;
          }

          const dt = Math.min(0.1, (timestamp - this.lastTime) / 1000);
          this.lastTime = timestamp;
          this.update(dt);
          this.render();
          this.input.endFrame();
          requestAnimationFrame((nextTimestamp) => this.loop(nextTimestamp));
        }

        render() {
          if (this.shakeTime > 0) {
            this.shakeTime = Math.max(0, this.shakeTime - 0.016);
            const shake = this.shakeTime * 0.6;
            this.camera.position.x = (Math.random() * 2 - 1) * shake;
            this.camera.position.y = 4.8 + (Math.random() * 2 - 1) * shake;
          } else {
            this.camera.position.x = 0;
            this.camera.position.y = 4.8;
          }
          this.camera.lookAt(0, 1.6, 0);
          this.renderer.render(this.scene, this.camera);
        }
      }

      /**
       * 5. INITIALIZATION
       */
      try {
        const root = document.getElementById("game-shell");
        new Game(root);
      } catch (error) {
        console.error(error);
      }
    </script>
  </body>
</html>
